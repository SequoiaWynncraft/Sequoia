<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequoia2 Chat</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/components.css">
    <!-- Custom Twemoji implementation - must be loaded first -->
    <script src="assets/js/twemoji/twemoji.js" type="text/javascript"></script>
    <!-- Wait for twemoji to initialize before loading other scripts -->
    <script type="text/javascript">
        // Make sure twemoji is loaded
        if (typeof twemoji === 'undefined') {
            console.error('Twemoji failed to initialize');
        } else {
            console.log('Twemoji loaded successfully');
        }
    </script>
    <!-- Emoji data and picker -->
    <script src="assets/js/emoji-data.js" type="text/javascript"></script>
    <script src="assets/js/emoji-picker.js" type="text/javascript"></script>
    <style>
        /* Material Design 3 Variables */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005E;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1E192B;
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-surface: #FEF7FF;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-outline-variant: #CAC4D0;
            --md-sys-color-shadow: #000000;
            --md-sys-color-surface-tint: #6750A4;
            --md-sys-color-inverse-surface: #313033;
            --md-sys-color-inverse-on-surface: #F4EFF4;
            --md-sys-color-error: #BA1A1A;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #FFDAD6;
            --md-sys-color-on-error-container: #410002;
            
            /* Chat-specific colors */
            --chat-bg-opacity: 0.95; /* Higher opacity since we don't have blur */
            --chat-input-bg: rgba(20, 20, 20, 0.95); /* More opaque instead of transparent */
            --chat-input-bg-rgb: 20, 20, 20;
            --chat-message-bg: rgba(255, 255, 255, 0.05);
            --chat-own-message-bg: rgba(255, 255, 255, 0.15);
            --chat-reply-line: rgba(255, 255, 255, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: transparent;
            color: white;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Chat Container */
        .chat-container {
            position: fixed;
            bottom: 20px; /* Changed from top to bottom for better positioning with reversed chat */
            left: 20px;
            width: 400px;
            max-width: none;
            height: 300px;
            background: rgba(var(--chat-bg-color), 0.95); /* More opaque instead of blur */
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            /* Removed backdrop-filter: blur */
            /* Removed -webkit-backdrop-filter: blur */
            font-family: 'Roboto', 'Segoe UI', system-ui, sans-serif;
            z-index: 9999;
            transition: all 0.3s var(--ease-out);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: row; /* Changed to row to place side menu and main chat side by side */
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
        }

        .chat-container.visible {
            opacity: 1;
            visibility: visible;
        }

        .chat-container.chat-open {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .chat-container.minimized {
            max-height: 120px;
        }
        
        
        /* Chat Tab Configuration */
        .chat-tab-config {
            display: flex;
            flex-direction: column;
            flex: 1 1 0%;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 0;
            background-color: rgba(20, 20, 20, 0.95); /* Using transparency matching chat input */
            margin: 0;
            border: 1px solid rgba(255, 255, 255, 0.12); /* Subtle border with transparency */
            backdrop-filter: blur(5px); /* Add blur effect if supported */
            -webkit-backdrop-filter: blur(5px);
            box-shadow: none;
        }
        
        .tab-config-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move; /* Make it draggable like the chat header */
        }
        
        /* Use existing chat-title styles for consistency */
        .tab-config-header .chat-title {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
            color: #ffffff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tab-config-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            overflow-y: auto;
            color: white; /* Ensure text is visible */
            padding: 20px;
        }
        
        .config-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .config-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }
        
        .config-field.name-field {
            flex: 2;
        }
        
        .config-field label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.87);
            font-weight: 500;
        }
        
        .config-field label .required {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .config-field input[type="text"],
        .config-field input[type="number"] {
            background-color: rgba(30, 30, 30, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            padding: 10px 12px;
            color: white;
            font-size: 14px;
            width: 100%;
            outline: none;
            transition: all 0.2s ease;
        }
        
        .config-field input[type="text"]:hover,
        .config-field input[type="number"]:hover {
            border-color: rgba(255, 255, 255, 0.3);
            background-color: rgba(40, 40, 40, 0.6);
        }
        
        .config-field input[type="text"]:focus,
        .config-field input[type="number"]:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.15);
            background-color: rgba(40, 40, 40, 0.8);
        }
        
        .config-section {
            margin-bottom: 20px;
        }
        
        .config-section-title {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.87);
        }
        
        .message-types-grid {
            display: grid;
            /* Auto-fit columns to use available horizontal space; reduce min width for denser layout */
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            grid-auto-flow: row dense;
            gap: 12px;
            margin-bottom: 20px;
            align-items: start;
            width: 100%;
        }

        /* Each checkbox becomes a full-width grid cell with the checkbox on the left and text filling the rest */
        .message-type-checkbox {
            display: grid;
            grid-template-columns: 22px 1fr;
            gap: 10px;
            align-items: center;
            padding: 10px 12px;
            background-color: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: box-shadow 0.15s ease, transform 0.08s ease;
            user-select: none;
            width: 100%;
            box-sizing: border-box;
        }

        .message-type-checkbox:hover {
            background-color: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.14);
            transform: translateY(-1px);
        }

        .message-type-checkbox.active {
            background-color: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.28);
            box-shadow: 0 2px 6px rgba(0,0,0,0.18);
        }

        .message-type-checkbox input[type="checkbox"] {
            margin: 0; /* checkbox placed by grid column */
            width: 18px;
            height: 18px;
            accent-color: rgba(255, 255, 255, 0.85);
            align-self: center;
        }

        /* Ensure label text doesn't wrap awkwardly and is vertically centered */
        .message-type-checkbox::after {
            content: '';
        }
        
        .tab-config-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 30px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .tab-config-btn {
            padding: 10px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }
        
        .tab-config-btn.cancel {
            background-color: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.87);
            border: 1px solid rgba(255, 255, 255, 0.12);
        }
        
        .tab-config-btn.save {
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.87);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .tab-config-btn.save-close {
            background-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .tab-config-btn:hover {
            filter: brightness(1.2);
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .tab-config-btn:active {
            filter: brightness(0.9);
            transform: translateY(0);
            box-shadow: none;
        }
        
        .filter-pattern-input {
            width: 100%;
            background-color: rgba(30, 30, 30, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            padding: 10px 12px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 14px;
            outline: none;
        }
        
        .filter-pattern-input:hover {
            border-color: rgba(255, 255, 255, 0.3);
            background-color: rgba(40, 40, 40, 0.6);
        }
        
        .filter-pattern-input:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.15);
            background-color: rgba(40, 40, 40, 0.8);
        }
        
        /* Custom checkbox styling */
        .custom-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            user-select: none;
        }
        
        .custom-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            background-color: rgba(30, 30, 30, 0.6);
            appearance: none;
            -webkit-appearance: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            vertical-align: middle;
            transition: all 0.2s ease;
        }
        
        .custom-checkbox input[type="checkbox"]:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background-color: rgba(40, 40, 40, 0.6);
        }
        
        .custom-checkbox input[type="checkbox"]:checked {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .custom-checkbox input[type="checkbox"]:checked::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 6px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .custom-checkbox label {
            cursor: pointer;
            user-select: none;
            color: rgba(255, 255, 255, 0.87);
            font-size: 14px;
        }
        
        .consuming-checkbox {
            background-color: rgba(40, 40, 40, 0.4);
            border-radius: 6px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            margin-top: 8px;
            transition: all 0.2s ease;
        }
        
        .consuming-checkbox:hover {
            background-color: rgba(50, 50, 50, 0.4);
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .minecraft-checkbox input[type="checkbox"]:checked::after {
            content: "";
            position: absolute;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .minecraft-checkbox label {
            color: #ffffff;
            cursor: pointer;
        }
        
        /* Tab config layout */
        .config-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .config-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .name-field {
            flex: 2;
        }
        
        .command-field {
            flex: 2;
        }
        
        .order-field {
            flex: 1;
        }
        
        .config-section {
            margin-bottom: 15px;
        }
        
        .config-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
            color: #ffffff;
        }
        
        .message-types-grid {
            display: grid;
            /* Auto-fit columns to available horizontal space; adjust min width for density */
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 12px;
            align-items: start;
        }

        /* Backwards-compatible helper if code injects rows */
        .checkbox-row {
            display: contents; /* allow grid cells to lay out naturally */
        }
        
        .required {
            color: #ff5555;
        }
        
        .full-width {
            width: 100%;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        
        .consuming-checkbox {
            margin-bottom: 15px;
        }
        
        /* Chat main content */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* Add position context for absolute positioned children */
        }

        .chat-container.chat-open {
            /* Removed max-height constraint to allow full resizing */
            width: 500px;
            display: flex;
        }

        /* Chat Side Menu */
        .chat-side-menu {
            width: 0;
            flex-shrink: 0;
            overflow: hidden;
            background-color: rgba(25, 25, 25, 0.75);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
            height: 100%; /* Ensure it fills the container height */
            border-bottom-left-radius: 11px; /* Match container's bottom-left radius minus border width */
            /* Add a clip path to ensure no border is shown at the bottom corner */
            clip-path: inset(0 0 0 0 round 11px 0 0 11px);
            /* Prevent scrollbar appearance during transition */
            -ms-overflow-style: none; /* Internet Explorer and Edge */
            scrollbar-width: none; /* Firefox */
        }
        
        /* Side menu content layout */
        .chat-side-menu-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Bottom fixed section */
        .chat-side-menu-bottom {
            flex-shrink: 0;
            margin-top: auto;
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        .chat-side-menu::-webkit-scrollbar,
        .chat-side-menu-content::-webkit-scrollbar {
            display: none;
        }

        .chat-side-menu.expanded {
            width: 65px;
        }

        .chat-side-menu.expanded-with-names {
            width: 180px;
        }
        
        /* Modal Styles */
        .chat-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .chat-modal-content {
            background-color: #36393f;
            border-radius: 5px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .chat-modal-header {
            padding: 16px;
            border-bottom: 1px solid #292b2f;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-modal-header h2 {
            margin: 0;
            font-size: 16px;
            color: #fff;
        }

        .chat-modal-close {
            cursor: pointer;
            font-size: 20px;
            color: #b9bbbe;
        }

        .chat-modal-body {
            padding: 16px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #b9bbbe;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background-color: #40444b;
            border: 1px solid #202225;
            border-radius: 3px;
            color: #dcddde;
            font-size: 14px;
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .chat-btn {
            padding: 8px 16px;
            border-radius: 3px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
        }

        .chat-btn-primary {
            background-color: #5865f2;
            color: white;
        }

        .chat-btn-secondary {
            background-color: #4f545c;
            color: white;
        }
        /* Chat tabs */
        .chat-tabs {
            display: flex;
            flex-direction: column;
            padding: 8px 0;
        }
        
        .chat-tab {
            position: relative;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            color: rgba(255, 255, 255, 0.7);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .chat-tab:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .chat-tab.active {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.15);
            border-left: 3px solid #42a5f5;
        }
        
        .chat-tab .material-icons {
            margin-right: 8px;
            font-size: 18px;
        }
        
        .chat-tab .tab-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-tabs {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 4px;
            padding-bottom: 8px; /* Add some bottom padding */
            margin-bottom: 0; /* No margin at bottom */
            overflow-y: auto;
            flex: 1; /* Take up all available space */
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent; /* For Firefox */
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        .chat-tabs::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-tabs::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-tabs::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .chat-tabs::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .chat-side-footer {
            padding: 0;
            border-top: none;
            display: none; /* Hide the footer since it's now empty */
        }

        .chat-tab {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: background-color 0.2s ease, color 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
        }

        .chat-tab:hover {
            background-color: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.9);
        }

        .chat-tab.active {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .chat-tab.add-tab-button {
            background-color: rgba(103, 80, 164, 0.2);
            border: 1px dashed rgba(255, 255, 255, 0.3);
            margin-top: 8px;
        }
        
        .chat-tab.add-tab-button:hover {
            background-color: rgba(103, 80, 164, 0.4);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .chat-tab .material-icons {
            font-size: 22px;
            flex-shrink: 0;
        }

        .chat-tab .tab-name {
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .chat-side-menu.expanded-with-names .chat-tab .tab-name {
            opacity: 1;
        }
        
        /* Chat tabs divider */
        .chat-tabs-divider {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 8px 8px;
        }
        
        /* Readonly tabs styles */
        .chat-tabs-readonly {
            padding-bottom: 8px;
            padding-top: 4px;
            display: flex;
            flex-direction: column-reverse; /* Reverse the order so new items grow from bottom */
            gap: 4px;
        }
        
        .chat-tab.readonly-tab {
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }
        
        .chat-tab.readonly-tab .material-icons {
            opacity: 0.7;
        }
        
        .chat-tab.readonly-tab:hover {
            background-color: rgba(255, 255, 255, 0.03);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .chat-tab.readonly-tab.active {
            background-color: rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.8);
        }
        
        .chat-tabs {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px 4px;
            overflow-y: auto;
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent; /* For Firefox */
        }
        
        .chat-tabs-main {
            flex: 1;
            overflow-y: auto;
        }

        /* Chat Main Content */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Ensure flex items can shrink below content size */
        }

        .chat-menu-toggle {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .chat-menu-toggle:hover {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* Chat Header */
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s var(--ease-out);
        }
        
        .chat-menu-toggle {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            transition: all 0.2s ease;
        }
        
        .chat-menu-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .chat-open .chat-header {
            opacity: 1;
            visibility: visible;
        }
        
        .chat-title {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
            color: #ffffff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-title {
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
        }

        .chat-controls {
            display: flex;
            gap: 8px;
        }

        .chat-control-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .chat-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-control-btn .material-icons {
            font-size: 16px;
        }

        /* Chat Messages */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
            display: flex;
            flex-direction: column-reverse; /* Reverse the direction: new messages at bottom */
            justify-content: flex-start; /* Align messages to the bottom */
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        /* Message */
        .message {
            margin-bottom: 4px;
            padding: 8px 10px; /* Increased padding for consistent height */
            min-height: 36px; /* Set a minimum height for all messages */
            border-radius: 4px;
            background: var(--chat-message-bg);
            transition: all 0.3s ease;
            position: relative;
            word-wrap: break-word;
            max-width: 100%;
            transform-origin: center bottom; /* Set transform origin to bottom for proper animation */
            display: flex;
            flex-direction: column; /* Stack content and reactions vertically */
        }

        .message:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .message.pinned {
            background: rgba(103, 80, 164, 0.2);
            border-left: 3px solid var(--md-sys-color-primary);
        }
        
        .message.pinned:hover {
            background: rgba(103, 80, 164, 0.3);
        }

        .message.fade-out {
            opacity: 0;
            transform: translateY(10px); /* Increased value for more visible animation */
            transition: opacity 0.3s cubic-bezier(0.2, 0.0, 0.0, 1), transform 0.3s cubic-bezier(0.2, 0.0, 0.0, 1);
        }

        /* Message Content */
        .message-content {
            font-size: 14px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.95);
            transition: opacity 0.2s ease;
            padding-right: 60px; /* Make room for timestamp and actions toggle */
            white-space: pre-line; /* Preserve line breaks */
            width: 100%; /* Ensure content takes full width */
        }

        .message-content.content-faded {
            opacity: 0.3;
        }
        
        /* Attachment preview styles */
        /* Channel-related styles */
        .channel-tag {
            display: inline-block;
            font-size: 0.85em;
            margin-right: 4px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .channel-tag.global {
            color: #a0a0a0;
        }
        
        .channel-tag.party {
            color: #5cb85c;
        }
        
        .channel-tag.guild {
            color: #428bca;
        }
        
        .channel-tag.private {
            color: #d9534f;
        }
        
        /* Side menu item unread indicator */
        .chat-tab.unread::after {
            content: '';
            display: block;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff5555;
            box-shadow: 0 0 4px rgba(255, 85, 85, 0.7);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 85, 85, 0.7);
            }
            70% {
                box-shadow: 0 0 0 5px rgba(255, 85, 85, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 85, 85, 0);
            }
        }
        
        .attachment-preview-container {
            position: relative;
            display: flex;
            align-items: center;
            margin-right: 8px;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 4px;
            max-width: 200px;
            flex-shrink: 0;
        }
        
        .attachment-preview {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 4px;
            position: relative;
            max-width: 100%;
            overflow: hidden;
            height: 32px;
        }
        
        .attachment-preview-img {
            max-width: 32px;
            max-height: 32px;
            border-radius: 4px;
            object-fit: cover;
        }
        
        .attachment-preview-file {
            display: flex;
            align-items: center;
            gap: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 4px;
            height: 100%;
        }
        
        .attachment-preview-file .material-icons {
            font-size: 18px;
            min-width: 18px;
        }
        
        .attachment-file-info {
            flex: 1;
            overflow: hidden;
            max-width: 120px;
        }
        
        .attachment-file-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 12px;
        }
        
        .attachment-file-size {
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .attachment-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
            border: none;
            z-index: 2;
        }
        
        .attachment-remove:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        /* Toast notification */
        .chat-toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            z-index: 10000;
            transition: transform 0.3s ease;
            font-size: 14px;
        }
        
        .chat-toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Timestamp styles */
        .message-timestamp {
            position: absolute;
            top: 50%;
            right: 40px; /* Moved to the right to make room for actions toggle */
            transform: translateY(-50%);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .message-timestamp.timestamp-visible {
            opacity: 1;
        }
        
        /* Message actions */
        .message-actions-toggle {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            width: 18px;  /* Smaller size to match timestamp */
            height: 18px; /* Smaller size to match timestamp */
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.7); /* Match timestamp color */
            font-size: 11px; /* Match timestamp font size */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .message:hover .message-actions-toggle {
            opacity: 1;
        }
        
        /* Make the more_vert icon smaller inside the toggle button */
        .message-actions-toggle .material-icons {
            font-size: 14px; /* Smaller size for the icon */
        }
        
        .message-actions-container {
            position: absolute;
            top: 0;
            right: 36px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 4px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateX(10px);
            transition: all 0.2s ease;
            visibility: hidden;
            z-index: 3;
        }
        
        .message-actions-container.active {
            opacity: 1;
            transform: translateX(0);
            visibility: visible;
        }
        
        .message-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 0 2px;
            transition: all 0.2s ease;
        }
        
        .message-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .message-action-btn .material-icons {
            font-size: 16px;
        }
        
        /* Reactions */
        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
            align-self: flex-start; /* Align to the left side */
            margin-left: 0; /* Ensure it starts from the left */
            margin-right: auto; /* Push to the left */
            padding-right: 60px; /* Make room for timestamp and actions */
        }
        
        .reaction {
            display: inline-flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 4px; /* Add space between content and reaction */
        }
        
        .reaction:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .reaction.active {
            background: rgba(103, 80, 164, 0.3);
            border-color: rgba(103, 80, 164, 0.5);
        }
        
        .reaction-emoji {
            margin-right: 4px;
            font-size: 16px;
        }
        
        .reaction-count {
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* Emoji picker with sidebar layout */
        #emoji-picker {
            position: fixed; /* Fixed to ensure it's always visible */
            top: auto; /* Will be set by JavaScript */
            left: auto; /* Will be set by JavaScript */
            background: rgba(20, 20, 20, 0.95); /* Darker and more opaque background */
            border-radius: 8px;
            padding: 0; /* Remove padding, we'll add it to child elements */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.1); /* Border glow effect */
            width: 440px; /* Wider to accommodate sidebar */
            height: 420px; /* Taller like Discord */
            display: none;
            flex-direction: column;
            z-index: 9999; /* Increased z-index to ensure it appears on top */
            overflow: hidden; /* Hide overflow */
            /* Removed backdrop-filter blur */
        }
        
        .emoji-picker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 8px 8px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            background: rgba(15, 15, 15, 0.95); /* Darker and more opaque than main background */
        }
        
        .emoji-picker-tabs {
            display: flex;
            gap: 8px;
            flex: 1;
        }
        
        .emoji-picker-tab {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 500;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }
        
        .emoji-picker-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
        }
        
        .emoji-picker-tab.active {
            background: rgba(103, 80, 164, 0.2);
            color: rgba(255, 255, 255, 0.95);
        }
        
        .emoji-picker-search {
            padding: 8px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(15, 15, 15, 0.95);
        }
        
        #emoji-search, #sticker-search, #gif-search {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            outline: none;
            height: 32px;
        }
        
        #emoji-search::placeholder, #sticker-search::placeholder, #gif-search::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        #emoji-picker-close {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            margin-left: 12px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        
        #emoji-picker-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        /* Emoji picker content layout */
        .emoji-picker-content {
            display: flex;
            flex-direction: column;
            height: calc(100% - 48px); /* Full height minus header */
        }
        
        .emoji-picker-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Left sidebar for categories */
        #emoji-category-nav {
            display: flex;
            flex-direction: column;
            width: 56px;
            padding: 8px 0;
            gap: 4px;
            background: rgba(15, 15, 15, 0.95);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }
        
        #emoji-category-nav::-webkit-scrollbar {
            height: 4px;
        }
        
        #emoji-category-nav::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #emoji-category-nav::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }
        
        /* Sidebar category buttons */
        .emoji-category-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 4px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .emoji-category-btn img {
            width: 24px;
            height: 24px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .emoji-category-btn:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .emoji-category-btn:hover img {
            opacity: 1;
        }
        
        .emoji-category-btn.active {
            background: rgba(103, 80, 164, 0.2);
        }
        
        .emoji-category-btn.active img {
            opacity: 1;
        }
        
        .emoji-category-btn.active::after {
            content: '';
            position: absolute;
            left: -4px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 20px;
            background-color: rgba(103, 80, 164, 0.8);
            border-radius: 0 2px 2px 0;
        }
        
        /* Emoji grid container */
        #emoji-results {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
            padding: 12px;
            align-content: start;
        }
        
        #emoji-results::-webkit-scrollbar {
            width: 6px;
        }
        
        #emoji-results::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #emoji-results::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .emoji-result-item {
            width: 36px;
            height: 36px;
            background: transparent;
            border: none;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 0;
        }
        
        .emoji-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .emoji-result-item img {
            width: 24px;
            height: 24px;
        }
        
        .emoji-no-results {
            grid-column: 1 / -1;
            padding: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
        }
        
        #emoji-preview {
            margin-top: 8px;
            padding: 8px 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            align-items: center;
            gap: 12px;
            background: rgba(15, 15, 15, 0.95); /* Darker and more opaque than main background */
        }
        
        #emoji-preview-emoji {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        
        #emoji-preview-emoji img {
            width: 28px;
            height: 28px;
        }
        
        #emoji-preview-name {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }
        
        /* Stickers and GIFs layouts */
        .stickers-content, .gifs-content {
            display: none;
            flex-direction: column;
            height: calc(100% - 48px);
        }
        
        .stickers-grid, .gifs-grid {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            align-content: start;
        }
        
        .sticker-item, .gif-item {
            aspect-ratio: 1/1;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .sticker-item:hover, .gif-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Placeholder styling for coming soon features */
        .placeholder-message {
            grid-column: 1 / -1;
            padding: 20px;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 250px;
        }
        
        .placeholder-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .placeholder-text h3 {
            margin: 0 0 8px 0;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .placeholder-text p {
            margin: 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            line-height: 1.4;
            max-width: 280px;
        }
        
        .emoji-item {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s ease;
            font-size: 20px;
        }
        
        .emoji-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .emoji-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .emoji-preview {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .emoji-preview-icon {
            font-size: 24px;
        }
        
        .emoji-preview-info {
            display: flex;
            flex-direction: column;
        }
        
        .emoji-preview-name {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .emoji-preview-shortcode {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .custom-emoji-tab {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
        }
        
        .custom-emoji-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Twemoji styling */
        .emoji {
            height: 1em;
            width: 1em;
            margin: 0 .05em 0 .1em;
            vertical-align: -0.1em;
        }
        
        /* Native emoji styling */
        .native-emoji {
            display: inline-block;
            font-size: 1.2em;
            line-height: 1;
            vertical-align: -0.1em;
            margin: 0 .05em;
        }

        /* No message actions or reactions in Minecraft-style chat */

        /* Chat Input */
        .chat-input-container {
            padding: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            width: 100%; /* Ensure full width */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .chat-container.chat-open .chat-input-container {
            display: block;
            width: 100%; /* Ensure full width when displayed */
        }

        .chat-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(var(--chat-input-bg-rgb, 20, 20, 20), 0.95); /* More opaque instead of blur */
            border-radius: 20px;
            padding: 6px 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative; /* Add positioning context for attachment preview */
            width: 100%; /* Take full width */
            box-sizing: border-box; /* Include padding in width calculation */
        }

        .chat-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: white;
            font-size: 13px;
            padding: 6px 0;
            font-family: inherit;
            resize: none;
            overflow-y: auto;
            max-height: 100px;
            line-height: 1.4;
            scrollbar-width: thin; /* Firefox */
            width: 100%; /* Ensure full width */
            min-width: 0; /* Allow flex item to shrink below content size */
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent; /* Firefox */
        }
        
        /* Custom scrollbar for Chrome, Safari and Opera */
        .chat-input::-webkit-scrollbar {
            width: 4px; /* Slightly thinner than chat-messages scrollbar */
        }
        
        .chat-input::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-input::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .chat-input::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        /* Reaction limit toast notification */
        .reaction-limit-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border: 1px solid rgba(103, 80, 164, 0.5);
        }
        
        .reaction-limit-toast.visible {
            opacity: 1;
        }
        
        /* Styles for reverse-i-search mode */
        .chat-input.search-mode {
            color: #ffffff;
            background-color: rgba(40, 40, 60, 0.9);
            border: 1px solid rgba(103, 80, 164, 0.6);
            border-radius: 4px;
            box-shadow: 0 0 8px rgba(103, 80, 164, 0.3);
            font-style: normal;
            padding: 6px 8px;
            width: calc(100% - 16px); /* Account for padding */
        }
        
        .search-prefix {
            color: var(--md-sys-color-primary);
            font-weight: bold;
        }
        
        .search-status {
            color: #8bc34a;
            font-weight: normal;
        }
        
        .search-query {
            color: #ffffff;
            font-weight: bold;
        }
        
        .search-result {
            color: #e0e0e0;
            font-style: italic;
            opacity: 0.9;
        }

        .chat-input-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0; /* Prevent actions from shrinking */
        }

        .input-action-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .input-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .input-action-btn.send {
            background: var(--md-sys-color-primary);
        }

        .input-action-btn.send:hover {
            background: var(--md-sys-color-primary);
            opacity: 0.8;
        }

        .input-action-btn .material-icons {
            font-size: 16px;
        }

        /* Animations */
        @keyframes messageAppear {
            0% {
                opacity: 0;
                transform: translateY(10px); /* Coming from below */
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Apply animation only to new messages */
        .new-message {
            animation: messageAppear 0.3s cubic-bezier(0.2, 0.0, 0.0, 1);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-container:hover .resize-handle {
            opacity: 1;
        }

        .resize-handle.se {
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: se-resize;
            background: linear-gradient(-45deg, transparent 30%, rgba(255, 255, 255, 0.3) 30%, rgba(255, 255, 255, 0.3) 50%, transparent 50%);
        }

        .resize-handle.s {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 4px;
            cursor: s-resize;
        }

        .resize-handle.e {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 20px;
            cursor: e-resize;
        }

        .resize-handle.sw {
            bottom: 0;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: sw-resize;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.3) 30%, rgba(255, 255, 255, 0.3) 50%, transparent 50%);
        }

        .resize-handle.ne {
            top: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: ne-resize;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.3) 30%, rgba(255, 255, 255, 0.3) 50%, transparent 50%);
        }

        .resize-handle.nw {
            top: 0;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: nw-resize;
            background: linear-gradient(-45deg, transparent 30%, rgba(255, 255, 255, 0.3) 30%, rgba(255, 255, 255, 0.3) 50%, transparent 50%);
        }

        .resize-handle.n {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 4px;
            cursor: n-resize;
        }

        .resize-handle.w {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 20px;
            cursor: w-resize;
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.98); /* More opaque instead of blur */
            border-radius: 16px;
            padding: 24px;
            width: 400px;
            /* Removed backdrop-filter: blur */
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            z-index: 1000;
        }

        .settings-modal.show {
            display: block;
        }

        .settings-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 20px;
            color: white;
        }

        .setting-group {
            margin-bottom: 16px;
        }

        .setting-label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setting-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            font-size: 14px;
            outline: none;
        }

        .setting-input:focus {
            border-color: var(--md-sys-color-primary);
        }

        .setting-range {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .setting-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--md-sys-color-primary);
            cursor: pointer;
        }
        
        /* Empty state styling for readonly tabs */
        .empty-state-message {
            background: transparent !important;
        }
        
        .empty-state-icon {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 16px;
            background: rgba(50, 50, 50, 0.4);
            color: rgba(255, 255, 255, 0.3);
        }

        .settings-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .settings-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .settings-btn.primary {
            background: var(--md-sys-color-primary);
            color: white;
        }

        .settings-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .settings-btn:hover {
            opacity: 0.8;
        }

        /* Hidden when not in chat mode */
        .chat-only {
            display: none;
        }

        .chat-container.chat-open .chat-only {
            display: block;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .chat-container {
                left: 10px;
                right: 10px;
                width: auto;
            }
            
            .chat-container.chat-open {
                width: auto;
            }
        }
        
        /* Media Queries for Responsiveness */
        @media screen and (max-width: 768px) {
            .chat-container {
                width: 100%;
                height: 100%;
                left: 0;
                top: 0;
                border-radius: 0;
            }
            
            .chat-input-container {
                padding: 8px;
            }
            
            .chat-input-wrapper {
                padding: 4px 8px;
            }
            
            .chat-input {
                font-size: 14px; /* Slightly larger for mobile */
            }
        }
    </style>
</head>
<body>
    <!-- Chat Container -->
    <div class="chat-container" id="chatContainer">
        <!-- Side Menu for Chat Tabs -->
        <div class="chat-side-menu" id="chatSideMenu">
            <div class="chat-side-menu-content">
                <!-- Regular Tabs Section -->
                <div class="chat-tabs chat-tabs-main">
                    <button class="chat-tab active" data-channel="all">
                        <span class="material-icons">forum</span>
                        <span class="tab-name">All</span>
                    </button>
                    <button class="chat-tab" data-channel="global">
                        <span class="material-icons">public</span>
                        <span class="tab-name">Global</span>
                    </button>
                    <button class="chat-tab" data-channel="guild">
                        <span class="material-icons">shield</span>
                        <span class="tab-name">Guild</span>
                    </button>
                    <button class="chat-tab" data-channel="party">
                        <span class="material-icons">groups</span>
                        <span class="tab-name">Party</span>
                    </button>
                    <button class="chat-tab" data-channel="private">
                        <span class="material-icons">person</span>
                        <span class="tab-name">Private</span>
                    </button>
                    <button class="chat-tab add-tab-button" data-channel="tab-config">
                        <span class="material-icons">add_circle</span>
                        <span class="tab-name">Add Tab</span>
                    </button>
                </div>
            </div>
            
            <!-- Bottom Fixed Section for Readonly Tabs -->
            <div class="chat-side-menu-bottom">
                <!-- Divider -->
                <div class="chat-tabs-divider"></div>
                
                <!-- Readonly Tabs Section -->
                <div class="chat-tabs chat-tabs-readonly">
                    <button class="chat-tab readonly-tab" data-channel="pinned" data-readonly="true">
                        <span class="material-icons">push_pin</span>
                        <span class="tab-name">Pinned Messages</span>
                    </button>
                    <button class="chat-tab readonly-tab" data-channel="bomb-bells" data-readonly="true">
                        <span class="material-icons">notifications_active</span>
                        <span class="tab-name">Bomb Bells</span>
                    </button>
                    <button class="chat-tab readonly-tab" data-channel="lfg" data-readonly="true">
                        <span class="material-icons">groups_2</span>
                        <span class="tab-name">LFG</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Main Content -->
        <div class="chat-main">
            <!-- Chat Header -->
            <div class="chat-header" id="chatHeader">
                <button class="chat-menu-toggle" id="chatMenuToggle" title="Toggle Chat Channels">
                    <span class="material-icons">menu</span>
                </button>
                <div class="chat-title">All Chat</div>
                <div class="chat-controls">
                    <button class="chat-control-btn" id="settingsBtn" title="Settings">
                        <span class="material-icons">settings</span>
                    </button>
                    <button class="chat-control-btn" id="minimizeBtn" title="Minimize">
                        <span class="material-icons">remove</span>
                    </button>
                </div>
            </div>

            <!-- Chat Messages -->
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be dynamically added here -->
            </div>

            <!-- Chat Input (only shown when chat is open) -->
            <div class="chat-input-container" id="chatInputContainer">
                <div class="chat-input-wrapper">
                    <textarea class="chat-input" id="chatInput" placeholder="Type a message..." rows="1"></textarea>
                    <div class="chat-input-actions">
                        <button class="input-action-btn" id="emojiBtn" title="Emoji">
                            <span class="material-icons">sentiment_satisfied</span>
                        </button>
                        <button class="input-action-btn" id="attachmentBtn" title="Attach File">
                            <span class="material-icons">attach_file</span>
                        </button>
                        <button class="input-action-btn send" id="sendBtn" title="Send">
                            <span class="material-icons">send</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Tab Configuration Section -->
            <div class="chat-tab-config" id="chatTabConfig" style="display: none;">
                <div class="tab-config-header" id="tabConfigHeader">
                    <div class="chat-menu-toggle" style="visibility: hidden;">
                        <span class="material-icons">menu</span>
                    </div>
                    <div class="chat-title" id="tabConfigTitle">Create New Tab</div>
                    <div class="chat-controls">
                        <button class="chat-control-btn" id="closeTabConfigBtn" title="Close">
                            <span class="material-icons">close</span>
                        </button>
                    </div>
                </div>
                <div class="tab-config-body">
                    <input type="hidden" id="channelId" value="">
                    
                    <div class="config-row">
                        <div class="config-field name-field">
                            <label for="channelName">Tab Name <span class="required">*</span></label>
                            <input type="text" id="channelName" placeholder="Enter tab name">
                        </div>
                        <div class="config-field command-field">
                            <label for="autoCommand">Auto Command</label>
                            <input type="text" id="autoCommand" placeholder="Command to run when tab is selected">
                        </div>
                        <div class="config-field order-field">
                            <label for="channelOrder">Display Order</label>
                            <input type="number" id="channelOrder" min="1" value="1">
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <div class="config-section-title">Message Types <span class="required">*</span></div>
                        <div class="message-types-grid">
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeInfo">
                                Info
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeClientside">
                                Clientside
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeNPC">
                                NPC
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeGlobal">
                                Global
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeLocal">
                                Local
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeGuild">
                                Guild
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeParty">
                                Party
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypePrivate">
                                Private
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeShout" checked>
                                Shout
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypePets">
                                Pets
                            </label>
                            <label class="message-type-checkbox">
                                <input type="checkbox" id="msgTypeGameMessage">
                                Game Message
                            </label>
                        </div>
                    </div>
                    
                    <div class="config-section">
                        <label class="custom-checkbox consuming-checkbox">
                            <input type="checkbox" id="consumeMessages">
                            <span>Consuming</span>
                        </label>
                    </div>
                    
                    <div class="config-section">
                        <label for="filterPattern">Filter Pattern</label>
                        <input type="text" id="filterPattern" class="filter-pattern-input" placeholder="Type here...">
                    </div>
                    
                    <div class="tab-config-actions">
                        <button id="cancelTabBtn" class="tab-config-btn cancel">Cancel</button>
                        <button id="saveTabBtn" class="tab-config-btn save">Save</button>
                        <button id="saveAndCloseTabBtn" class="tab-config-btn save-close">Save and Close</button>
                    </div>
                </div>
            </div>
        </div> <!-- End chat-main -->

        <!-- Resize Handle -->
        <!-- Resize handles -->
        <div class="resize-handle se" data-direction="se"></div>
        <div class="resize-handle s" data-direction="s"></div>
        <div class="resize-handle e" data-direction="e"></div>
        <div class="resize-handle sw" data-direction="sw"></div>
        <div class="resize-handle ne" data-direction="ne"></div>
        <div class="resize-handle nw" data-direction="nw"></div>
        <div class="resize-handle n" data-direction="n"></div>
        <div class="resize-handle w" data-direction="w"></div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-title">Chat Settings</div>
        
        <div class="setting-group">
            <label class="setting-label">Font Size</label>
            <input type="range" class="setting-range" id="fontSizeRange" min="10" max="20" value="13">
            <span id="fontSizeValue">13px</span>
        </div>

        <div class="setting-group">
            <label class="setting-label">Background Opacity</label>
            <input type="range" class="setting-range" id="opacityRange" min="0.3" max="1" step="0.1" value="0.85">
            <span id="opacityValue">85%</span>
        </div>

        <div class="setting-group">
            <label class="setting-label">Chat Width</label>
            <input type="range" class="setting-range" id="widthRange" min="300" max="800" value="400">
            <span id="widthValue">400px</span>
        </div>

        <div class="setting-group">
            <label class="setting-label">Chat Height</label>
            <input type="range" class="setting-range" id="heightRange" min="200" max="1000" value="300">
            <span id="heightValue">300px</span>
        </div>

        <div class="settings-actions">
            <button class="settings-btn secondary" id="cancelSettings">Cancel</button>
            <button class="settings-btn primary" id="saveSettings">Save</button>
        </div>
    </div>

    <script type="text/javascript">
        class SequoiaChat {
            constructor() {
                this.isOpen = false;
                this.isDragging = false;
                this.isResizing = false;
                this.messages = [];
                this.messageTimeout = 10000; // 10 seconds
                this.maxMessages = 100; // Increased max messages for Minecraft-style chat
                this.dragStart = { left: 0, top: 0, mouseX: 0, mouseY: 0 };
                this.resizeStart = { mouseX: 0, mouseY: 0, width: 0, height: 0, left: 0, top: 0 };
                this.resizeDirection = '';
                this.fadeTimeout = null;
                this.lastMessageTime = 0;
                this.minWidth = 200;
                this.minHeight = 150;
                this.edgePadding = 20; // Padding from browser edges (in pixels)
                
                // Chat channels
                this.activeChannel = 'all'; // Default channel: all messages
                
                // Attachment tracking
                this.currentAttachment = null;
                
                // Settings
                this.settings = {
                    fontSize: 13,
                    opacity: 0.85,
                    width: 400,
                    height: 300,
                    left: 20,
                    top: window.innerHeight - 320 // Keep this for compatibility with existing code
                };

                try {
                    console.log('Starting chat initialization');
                    this.init();
                    this.loadSettings();
                    this.bindEvents();
                    this.initSideMenu();
                    console.log('Chat initialization completed');
                } catch (error) {
                    console.error('Error during chat initialization:', error);
                }
            }
            
            initSideMenu() {
                console.log('Initializing side menu');
                // Expand side menu by default
                const sideMenu = document.getElementById('chatSideMenu');
                if (sideMenu) {
                    console.log('Side menu found, expanding');
                    sideMenu.classList.add('expanded');
                    
                    // Load any custom chat channels
                    this.loadCustomChannels();
                } else {
                    console.log('Side menu element not found!');
                }
                
                // Start with chat hidden (no messages initially)
                // Remove demo messages - chat should be invisible until first message arrives
            }

            init() {
                console.log('Initializing chat components');
                this.chatContainer = document.getElementById('chatContainer');
                this.chatMessages = document.getElementById('chatMessages');
                this.chatInput = document.getElementById('chatInput');
                this.settingsModal = document.getElementById('settingsModal');
                
                // Check if required elements exist
                if (!this.chatContainer || !this.chatMessages) {
                    console.error('Required chat elements not found!');
                }
                
                // Initialize message history for up/down navigation
                if (!this.messageHistory) {
                    this.messageHistory = [];
                }
                this.historyIndex = -1;
                this.currentInput = '';
                this.searchMode = false;
                this.searchTerm = '';
                this.searchResults = [];
                this.searchIndex = -1;
                
                // Load message history from localStorage if available
                try {
                    const savedHistory = localStorage.getItem('sequoiaChatHistory');
                    if (savedHistory) {
                        this.messageHistory = JSON.parse(savedHistory);
                        // Limit to 50 messages if needed
                        if (this.messageHistory.length > 50) {
                            this.messageHistory = this.messageHistory.slice(-50);
                        }
                    }
                } catch (e) {
                    console.error('Error loading chat history', e);
                    this.messageHistory = [];
                }
                
                // Initialize channel settings
                this.currentChannel = 'all';
                this.channels = {
                    'all': { name: 'All Chat', icon: 'forum', messages: [] },
                    'global': { name: 'Global', icon: 'public', messages: [] },
                    'guild': { name: 'Guild', icon: 'shield', messages: [] },
                    'party': { name: 'Party', icon: 'groups', messages: [] },
                    'private': { name: 'Private', icon: 'person', messages: [] }
                };
                
                // Ensure the chat is within browser boundaries
                this.ensureWithinBounds();
                
                // Set initial position
                this.updatePosition();
                this.updateSize();
                this.updateOpacity();
            }
            
            // Auto-resize textarea based on content
            autoResizeTextarea() {
                // Reset height to auto to get the correct scrollHeight
                this.chatInput.style.height = 'auto';
                
                // Set the height to the scrollHeight to fit the content
                this.chatInput.style.height = this.chatInput.scrollHeight + 'px';
            }
            
            ensureWithinBounds() {
                // Get browser dimensions
                const browserWidth = window.innerWidth;
                const browserHeight = window.innerHeight;
                
                // Ensure width and height don't exceed browser dimensions minus padding
                const maxWidth = browserWidth - this.edgePadding * 2;
                const maxHeight = browserHeight - this.edgePadding * 2;
                
                this.settings.width = Math.min(this.settings.width, maxWidth);
                this.settings.height = Math.min(this.settings.height, maxHeight);
                
                // Ensure left position respects padding
                if (this.settings.left < this.edgePadding) {
                    this.settings.left = this.edgePadding;
                }
                
                // Ensure right edge respects padding
                if (this.settings.left + this.settings.width > browserWidth - this.edgePadding) {
                    this.settings.left = browserWidth - this.settings.width - this.edgePadding;
                }
                
                // For bottom-to-top chat, we need to ensure the bottom edge is visible
                // Convert top position to be relative to bottom for better positioning
                if (browserHeight - this.settings.top - this.settings.height < this.edgePadding) {
                    this.settings.top = browserHeight - this.settings.height - this.edgePadding;
                }
                
                // Ensure top edge respects padding
                if (this.settings.top < this.edgePadding) {
                    this.settings.top = this.edgePadding;
                }
            }
            
            // Initialize side menu functionality
            initSideMenu() {
                this.sideMenu = document.getElementById('chatSideMenu');
                this.chatMenuToggle = document.getElementById('chatMenuToggle');
                this.chatTabs = document.querySelectorAll('.chat-tab');
                this.chatTitle = document.querySelector('.chat-title');
                
                // Set initial state
                this.sideMenuExpanded = false;
                this.sideMenuWithNames = false;
                
                // Add event listeners for menu toggle
                this.chatMenuToggle.addEventListener('click', () => this.toggleSideMenu());
                
                // Add event listeners for chat tabs
                this.chatTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const channel = tab.getAttribute('data-channel');
                        if (channel) {
                            this.switchChannel(channel);
                        } else if (tab.id === 'chatUserList') {
                            this.toggleUserList();
                        }
                    });
                });
                
                // Double click on side menu to expand with names
                this.sideMenu.addEventListener('dblclick', (e) => {
                    if (e.target === this.sideMenu || e.target.classList.contains('chat-tabs')) {
                        this.toggleSideMenuWithNames();
                    }
                });
            }
            
            // Toggle side menu visibility
            toggleSideMenu() {
                this.sideMenuExpanded = !this.sideMenuExpanded;
                
                if (this.sideMenuExpanded) {
                    if (this.sideMenuWithNames) {
                        this.sideMenu.classList.add('expanded-with-names');
                        this.sideMenu.classList.remove('expanded');
                    } else {
                        this.sideMenu.classList.add('expanded');
                        this.sideMenu.classList.remove('expanded-with-names');
                    }
                } else {
                    this.sideMenu.classList.remove('expanded');
                    this.sideMenu.classList.remove('expanded-with-names');
                }
            }
            
            // Toggle between icon-only and full-width side menu
            toggleSideMenuWithNames() {
                if (!this.sideMenuExpanded) {
                    this.toggleSideMenu();
                    this.sideMenuWithNames = true;
                    this.sideMenu.classList.add('expanded-with-names');
                    this.sideMenu.classList.remove('expanded');
                } else {
                    this.sideMenuWithNames = !this.sideMenuWithNames;
                    if (this.sideMenuWithNames) {
                        this.sideMenu.classList.add('expanded-with-names');
                        this.sideMenu.classList.remove('expanded');
                    } else {
                        this.sideMenu.classList.add('expanded');
                        this.sideMenu.classList.remove('expanded-with-names');
                    }
                }
            }
            
            // Switch chat channel
            switchChannel(channel) {
                // Do nothing if already on this channel
                if (channel === this.currentChannel) return;
                
                // Update active tab
                this.chatTabs.forEach(tab => {
                    if (tab.getAttribute('data-channel') === channel) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
                
                // Update current channel
                this.currentChannel = channel;
                
                // Update header title
                if (this.chatTitle && this.channels[channel]) {
                    this.chatTitle.textContent = this.channels[channel].name;
                }
                
                // Filter messages for this channel
                this.updateChannelMessages();
            }
            
            // Update messages displayed based on current channel
            updateChannelMessages() {
                // For now, just show all messages regardless of channel
                // In a real implementation, you would filter messages by channel
                
                // Clear current messages
                this.chatMessages.innerHTML = '';
                
                // Get messages for current channel
                const messages = this.channels[this.currentChannel].messages;
                
                // Display messages for the selected channel
                // In a production environment, you would implement message filtering here
                // For now, we'll keep the same behavior
                
                // For demo, add a message showing the channel change
                const channelMessage = document.createElement('div');
                channelMessage.className = 'message system';
                channelMessage.innerHTML = `<div class="message-content">Switched to ${this.channels[this.currentChannel].name}</div>`;
                this.chatMessages.appendChild(channelMessage);
            }
            
            // Toggle user list
            toggleUserList() {
                // Placeholder function for future user list implementation
                const userListMessage = document.createElement('div');
                userListMessage.className = 'message system';
                userListMessage.innerHTML = '<div class="message-content">User list feature coming soon!</div>';
                this.chatMessages.appendChild(userListMessage);
                this.scrollToBottom();
            }

            bindEvents() {
                try {
                    console.log('Binding events to chat elements');
                    
                    // Chat header dragging
                    const chatHeader = document.getElementById('chatHeader');
                    if (chatHeader) {
                        chatHeader.addEventListener('mousedown', this.startDrag.bind(this));
                    } else {
                        console.warn('Chat header element not found');
                    }
                    
                    // Resize handle events
                    const resizeHandles = document.querySelectorAll('.resize-handle');
                    resizeHandles.forEach(handle => {
                        handle.addEventListener('mousedown', this.startResize.bind(this));
                    });
                    
                    // Global mouse events
                    document.addEventListener('mousemove', this.onMouseMove.bind(this));
                    document.addEventListener('mouseup', this.onMouseUp.bind(this));
                    
                    // Window resize event to keep chat within bounds
                    window.addEventListener('resize', () => {
                        this.ensureWithinBounds();
                        this.updatePosition();
                        this.updateSize();
                    });
                    
                    // Channel menu toggle - button event listener is already set up in initSideMenu
                    const menuToggleBtn = document.getElementById('chatMenuToggle');
                    if (!menuToggleBtn) {
                        console.warn('Menu toggle button not found!');
                    }
                    
                    // Channel switching - add a check to ensure elements exist
                    const channelTabs = document.querySelectorAll('.chat-tab[data-channel]');
                    console.log(`Found ${channelTabs.length} channel tabs`);
                    
                    channelTabs.forEach(item => {
                        const channel = item.getAttribute('data-channel');
                        console.log(`Adding click listener for channel: ${channel}`);
                        
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            console.log(`Channel tab clicked: ${channel}`);
                            this.switchChannel(channel);
                        });
                        
                        // Add context menu event to tabs
                        item.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            // Only allow editing custom tabs
                            if (!['all', 'global', 'guild', 'party', 'private'].includes(channel)) {
                                this.showTabContextMenu(e, channel);
                            }
                        });
                    });
                
                // Add event listener for createChannelBtn
                const createChannelBtn = document.getElementById('createChannelBtn');
                if (createChannelBtn) {
                    createChannelBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        // Get the form values
                        const name = document.getElementById('channelName').value.trim();
                        const icon = document.getElementById('channelIcon').value;
                        const autoCommand = document.getElementById('autoCommand').value.trim();
                        const consumeMessages = document.getElementById('consumeMessages').checked;
                        const filterPattern = document.getElementById('filterPattern').value.trim();
                        
                        // Message types
                        const messageTypes = [];
                        if (document.getElementById('msgTypeGlobal').checked) messageTypes.push('global');
                        if (document.getElementById('msgTypeGuild').checked) messageTypes.push('guild');
                        if (document.getElementById('msgTypeParty').checked) messageTypes.push('party');
                        if (document.getElementById('msgTypePrivate').checked) messageTypes.push('private');
                        if (document.getElementById('msgTypeSystem').checked) messageTypes.push('system');
                        if (document.getElementById('msgTypeCombat').checked) messageTypes.push('combat');
                        
                        // Validate the channel name
                        if (!name) {
                            alert('Please enter a tab name');
                            return;
                        }
                        
                        // Create the tab
                        this.createNewTab(
                            name,
                            icon,
                            autoCommand,
                            messageTypes,
                            consumeMessages,
                            filterPattern
                        );
                        
                        // Reset the form
                        document.getElementById('channelName').value = '';
                        document.getElementById('channelIcon').value = 'chat';
                        document.getElementById('autoCommand').value = '';
                        document.getElementById('consumeMessages').checked = false;
                        document.getElementById('filterPattern').value = '';
                        
                        // Switch to the newly created tab
                        this.switchChannel(name.toLowerCase().replace(/\s+/g, '-'));
                    });
                }
                
                // Chat input
                this.chatInput.addEventListener('input', () => {
                    this.autoResizeTextarea();
                });
                
                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (e.shiftKey) {
                            // Add a new line instead of sending when Shift+Enter is pressed
                            // No need to manually insert \n as the default behavior will do this
                            return true;
                        } else {
                            // Send message on regular Enter press
                            e.preventDefault(); // Prevent default newline
                            this.sendMessage();
                        }
                    }
                });
                
                // Add click handler to maintain cursor position in search mode
                this.chatInput.addEventListener('click', (e) => {
                    if (this.searchMode) {
                        const cursorPos = this.chatInput.selectionStart;
                        if (cursorPos < this.promptEndPosition) {
                            // Prevent cursor from going before the search term
                            setTimeout(() => {
                                this.chatInput.selectionStart = this.chatInput.selectionEnd = this.promptEndPosition;
                            }, 0);
                        }
                    }
                });
                
                // Add keydown handler for up/down arrow and reverse-i-search
                this.chatInput.addEventListener('keydown', (e) => {
                    console.log('Key down event:', e.key);
                    
                    // Exit search mode if Escape is pressed
                    if (e.key === 'Escape' && this.searchMode) {
                        this.exitSearchMode();
                        e.preventDefault();
                        return;
                    }
                    
                    // Select search result if Enter or Tab is pressed in search mode
                    if ((e.key === 'Enter' || e.key === 'Tab') && this.searchMode) {
                        console.log('Enter/Tab pressed in search mode');
                        if (this.searchIndex >= 0 && this.searchResults.length > 0) {
                            // Use the matched message as the current input
                            this.chatInput.value = this.searchResults[this.searchIndex];
                        }
                        this.exitSearchMode();
                        e.preventDefault();
                        return;
                    }
                    
                    // Enter reverse-i-search mode with Ctrl+R
                    if (e.ctrlKey && e.key === 'r') {
                        console.log('Ctrl+R pressed');
                        if (!this.searchMode) {
                            this.enterSearchMode();
                        } else {
                            this.searchNext(false); // Search next match (backward)
                        }
                        e.preventDefault();
                        return;
                    }
                    
                    // Handle search mode input
                    if (this.searchMode) {
                        // Handle left/right arrow keys to prevent moving cursor before search term
                        if (e.key === 'ArrowLeft') {
                            const cursorPos = this.chatInput.selectionStart;
                            const minPos = this.promptEndPosition;
                            if (cursorPos <= minPos) {
                                e.preventDefault(); // Prevent moving cursor before the search term
                            }
                        } 
                        // Handle backspace
                        else if (e.key === 'Backspace') {
                            if (this.searchTerm.length > 0) {
                                this.searchTerm = this.searchTerm.slice(0, -1);
                                this.updateSearchResults();
                            }
                            e.preventDefault(); // Always prevent default to protect the search prompt text
                        } 
                        // Handle normal text input
                        else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                            this.searchTerm += e.key;
                            this.updateSearchResults();
                            e.preventDefault();
                        }
                        // Prevent any other key from affecting the input in search mode
                        else {
                            // Allow specific keys (like arrows, esc, enter, tab) to pass through
                            // for navigation but prevent others
                            if (!['ArrowUp', 'ArrowDown', 'ArrowRight', 'Escape', 'Enter', 'Tab'].includes(e.key)) {
                                e.preventDefault();
                            }
                        }
                        return;
                    }
                    
                    // Regular history navigation with up/down arrows
                    if (e.key === 'ArrowUp') {
                        console.log('Arrow Up pressed');
                        // Make sure history array exists
                        if (!this.messageHistory) {
                            this.messageHistory = [];
                            console.log('Initialized empty message history');
                        }
                        console.log('Current message history:', this.messageHistory);
                        if (this.messageHistory.length > 0) {
                            console.log('Navigating history forward');
                            this.navigateHistory(1); // Go forward in history (more recent message)
                            e.preventDefault();
                        } else {
                            console.log('No message history, not navigating');
                        }
                    } else if (e.key === 'ArrowDown') {
                        console.log('Arrow Down pressed');
                        if (!this.messageHistory) {
                            this.messageHistory = [];
                        }
                        this.navigateHistory(-1); // Go backward in history (older message)
                        e.preventDefault();
                    }
                });
                
                // Send button
                document.getElementById('sendBtn').addEventListener('click', this.sendMessage.bind(this));
                
                // Settings
                document.getElementById('settingsBtn').addEventListener('click', this.openSettings.bind(this));
                document.getElementById('saveSettings').addEventListener('click', this.saveSettings.bind(this));
                document.getElementById('cancelSettings').addEventListener('click', this.closeSettings.bind(this));
                
                // Settings inputs
                this.bindSettingsInputs();
                
                // Minimize button
                const minimizeBtn = document.getElementById('minimizeBtn');
                if (minimizeBtn) {
                    minimizeBtn.addEventListener('click', this.toggleMinimize.bind(this));
                } else {
                    console.warn('Minimize button not found');
                }
                
                // Initialize modal close buttons
                document.querySelectorAll('.chat-modal-close').forEach(closeBtn => {
                    closeBtn.addEventListener('click', () => {
                        closeBtn.closest('.chat-modal').style.display = 'none';
                    });
                });
                
                // Create Channel Modal
                const createChannelModalBtn = document.getElementById('createChannelBtn');
                if (createChannelModalBtn) {
                    createChannelModalBtn.addEventListener('click', () => {
                        const channelName = document.getElementById('channelName')?.value || '';
                        const channelIcon = document.getElementById('channelIcon')?.value || '';
                        const autoCommand = document.getElementById('autoCommand')?.value || '';
                        
                        const messageTypes = {
                            global: document.getElementById('msgTypeGlobal')?.checked || false,
                            guild: document.getElementById('msgTypeGuild')?.checked || false,
                            party: document.getElementById('msgTypeParty')?.checked || false,
                            private: document.getElementById('msgTypePrivate')?.checked || false,
                            system: document.getElementById('msgTypeSystem')?.checked || false,
                            combat: document.getElementById('msgTypeCombat')?.checked || false
                        };
                        
                        const consumeMessages = document.getElementById('consumeMessages')?.checked || false;
                        const filterPattern = document.getElementById('filterPattern')?.value || '';
                        
                        this.createNewTab(
                            channelName,
                            channelIcon,
                            autoCommand,
                            messageTypes,
                            consumeMessages,
                            filterPattern
                        );
                        
                        const createChannelModal = document.getElementById('createChannelModal');
                        if (createChannelModal) {
                            createChannelModal.style.display = 'none';
                        }
                    });
                } else {
                    console.warn('Create channel button not found');
                }
                
                // Edit Channel Modal
                const updateChannelBtn = document.getElementById('updateChannelBtn');
                if (updateChannelBtn) {
                    updateChannelBtn.addEventListener('click', () => {
                        const editChannelId = document.getElementById('editChannelId')?.value || '';
                        const editChannelName = document.getElementById('editChannelName')?.value || '';
                        const editChannelIcon = document.getElementById('editChannelIcon')?.value || '';
                        const editAutoCommand = document.getElementById('editAutoCommand')?.value || '';
                        
                        const messageTypes = {
                            global: document.getElementById('editMsgTypeGlobal')?.checked || false,
                            guild: document.getElementById('editMsgTypeGuild')?.checked || false,
                            party: document.getElementById('editMsgTypeParty')?.checked || false,
                            private: document.getElementById('editMsgTypePrivate')?.checked || false,
                            system: document.getElementById('editMsgTypeSystem')?.checked || false,
                            combat: document.getElementById('editMsgTypeCombat')?.checked || false
                        };
                        
                        const editConsumeMessages = document.getElementById('editConsumeMessages')?.checked || false;
                        const editFilterPattern = document.getElementById('editFilterPattern')?.value || '';
                        
                        this.updateTab(
                            editChannelId,
                            editChannelName,
                            editChannelIcon,
                            editAutoCommand,
                            messageTypes,
                            editConsumeMessages,
                            editFilterPattern
                        );
                        
                        const editChannelModal = document.getElementById('editChannelModal');
                        if (editChannelModal) {
                            editChannelModal.style.display = 'none';
                        }
                    });
                } else {
                    console.warn('Update channel button not found');
                }
                
                const deleteChannelBtn = document.getElementById('deleteChannelBtn');
                if (deleteChannelBtn) {
                    deleteChannelBtn.addEventListener('click', () => {
                        const editChannelId = document.getElementById('editChannelId')?.value || '';
                        this.deleteTab(editChannelId);
                        
                        const editChannelModal = document.getElementById('editChannelModal');
                        if (editChannelModal) {
                            editChannelModal.style.display = 'none';
                        }
                    });
                } else {
                    console.warn('Delete channel button not found');
                }
                
                // Emoji button
                const emojiBtn = document.getElementById('emojiBtn');
                if (emojiBtn) {
                    emojiBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Set the data mode directly on the emoji picker element
                        if (window.emojiPicker && document.getElementById('emoji-picker')) {
                            document.getElementById('emoji-picker').setAttribute('data-mode', 'normal');
                            window.emojiPicker.toggle();
                        } else {
                            console.log("Emoji picker not initialized yet");
                        }
                    });
                } else {
                    console.warn('Emoji button not found');
                }
                
                // Attachment button
                const attachmentBtn = document.getElementById('attachmentBtn');
                if (attachmentBtn) {
                    attachmentBtn.addEventListener('click', () => {
                        // Call to Java function through MCEF bridge
                        try {
                            if (window.javabridge && window.javabridge.openFileSelector) {
                                window.javabridge.openFileSelector();
                            } else {
                                console.log('File attachment - Java bridge not available');
                                this.showToast('File attachment feature is being set up...');
                                // For testing in browser
                                this.simulateFileAttachment();
                            }
                        } catch (e) {
                            console.error('Error calling Java function:', e);
                            this.showToast('Could not open file selector');
                        }
                    });
                } else {
                    console.warn('Attachment button not found');
                }
                
                console.log('Event binding completed successfully');
            } catch (error) {
                console.error('Error in bindEvents method:', error);
            }
        }

        bindSettingsInputs() {
            try {
                const fontSizeRange = document.getElementById('fontSizeRange');
                const opacityRange = document.getElementById('opacityRange');
                const widthRange = document.getElementById('widthRange');
                const heightRange = document.getElementById('heightRange');
                
                if (fontSizeRange) {
                    fontSizeRange.addEventListener('input', (e) => {
                        const fontSizeValue = document.getElementById('fontSizeValue');
                        if (fontSizeValue) {
                            fontSizeValue.textContent = e.target.value + 'px';
                        }
                    });
                }
                
                if (opacityRange) {
                    opacityRange.addEventListener('input', (e) => {
                        const opacityValue = document.getElementById('opacityValue');
                        if (opacityValue) {
                            opacityValue.textContent = Math.round(e.target.value * 100) + '%';
                        }
                    });
                }
                
                if (widthRange) {
                    widthRange.addEventListener('input', (e) => {
                        const widthValue = document.getElementById('widthValue');
                        if (widthValue) {
                            widthValue.textContent = e.target.value + 'px';
                        }
                    });
                }
                
                if (heightRange) {
                    heightRange.addEventListener('input', (e) => {
                        const heightValue = document.getElementById('heightValue');
                        if (heightValue) {
                            heightValue.textContent = e.target.value + 'px';
                        }
                    });
                }
            } catch (error) {
                console.error('Error binding settings inputs:', error);
            }
        }

        openChat() {
                this.isOpen = true;
                this.chatContainer.classList.add('chat-open');
                this.showChat(); // Always show when opening
                this.chatInput.focus();
                
                // Reset textarea height to default
                this.chatInput.style.height = 'auto';
                this.autoResizeTextarea();
                
                // Clear auto-fade timer when chat is opened
                if (this.fadeTimeout) {
                    clearTimeout(this.fadeTimeout);
                    this.fadeTimeout = null;
                }
                
                console.log('Chat opened');
            }
            
            // History navigation methods
            navigateHistory(direction) {
                console.log('Navigate history called with direction:', direction);
                
                // Initialize history if it doesn't exist
                if (!this.messageHistory) {
                    console.log('History not initialized, creating empty array');
                    this.messageHistory = [];
                    this.historyIndex = -1;
                    this.currentInput = '';
                }
                
                console.log('Current history:', this.messageHistory);
                console.log('Current historyIndex:', this.historyIndex);
                
                // Store current input if we're starting navigation
                if (this.historyIndex === -1 && direction < 0) {
                    this.currentInput = this.chatInput.value;
                    console.log('Storing current input:', this.currentInput);
                }
                
                // Calculate new index
                const newIndex = this.historyIndex + direction;
                console.log('New index would be:', newIndex);
                
                // Bounds checking
                if (newIndex >= this.messageHistory.length || newIndex < -1) {
                    console.log('New index out of bounds, not changing');
                    return;
                }
                
                // Update index
                this.historyIndex = newIndex;
                console.log('Updated historyIndex to:', this.historyIndex);
                
                // Update input value
                if (this.historyIndex === -1) {
                    // Restore original input
                    this.chatInput.value = this.currentInput;
                    console.log('Restored to original input:', this.currentInput);
                } else {
                    // Set to history item
                    const historyItem = this.messageHistory[this.messageHistory.length - 1 - this.historyIndex];
                    console.log('Setting to history item:', historyItem, 'at position', this.messageHistory.length - 1 - this.historyIndex);
                    this.chatInput.value = historyItem;
                }
                
                // Move cursor to end
                setTimeout(() => {
                    this.chatInput.selectionStart = this.chatInput.selectionEnd = this.chatInput.value.length;
                }, 0);
            }
            
            // Reverse-i-search methods
            enterSearchMode() {
                console.log('Entering search mode');
                
                // Initialize message history if needed
                if (!this.messageHistory) {
                    console.log('Initializing messageHistory in enterSearchMode');
                    this.messageHistory = [];
                }
                
                this.searchMode = true;
                this.searchTerm = '';
                this.searchResults = [];
                this.searchIndex = -1;
                
                // Save current input
                this.currentInput = this.chatInput.value;
                console.log('Saved current input:', this.currentInput);
                
                // Add search mode styling
                this.chatInput.classList.add('search-mode');
                
                // Update input to show search prompt
                this.updateSearchPrompt();
                
                // Initialize the prompt end position (where the search term begins)
                this.promptEndPosition = this.chatInput.value.indexOf(': ') + 2;
                
                // Set cursor position after the search prompt
                setTimeout(() => {
                    // Position cursor right after the search prompt text
                    this.chatInput.selectionStart = this.chatInput.selectionEnd = this.promptEndPosition;
                }, 0);
            }
            
            exitSearchMode() {
                console.log('Exiting search mode');
                this.searchMode = false;
                this.chatInput.classList.remove('search-mode');
                
                if (this.searchIndex >= 0 && this.searchResults.length > 0) {
                    console.log('Setting input to selected result:', this.currentInput);
                    this.chatInput.value = this.currentInput;
                } else {
                    console.log('Restoring original input:', this.currentInput);
                    this.chatInput.value = this.currentInput;
                }
                
                // Adjust textarea height based on content
                this.autoResizeTextarea();
                
                // Move cursor to end
                setTimeout(() => {
                    this.chatInput.selectionStart = this.chatInput.selectionEnd = this.chatInput.value.length;
                }, 0);
            }
            
            updateSearchResults() {
                console.log('Updating search results for term:', this.searchTerm);
                
                // Initialize message history if needed
                if (!this.messageHistory) {
                    console.log('Initializing messageHistory in updateSearchResults');
                    this.messageHistory = [];
                }
                
                if (this.searchTerm.length === 0) {
                    this.searchResults = [];
                    this.searchIndex = -1;
                    this.updateSearchPrompt();
                    return;
                }
                
                // Find all matches
                this.searchResults = this.messageHistory.filter(msg => 
                    msg.toLowerCase().includes(this.searchTerm.toLowerCase())
                );
                
                console.log('Found matches:', this.searchResults);
                
                // Reset index and update display
                this.searchIndex = this.searchResults.length - 1;
                console.log('Setting searchIndex to:', this.searchIndex);
                this.updateSearchDisplay();
            }
            
            searchNext(forward = false) {
                if (this.searchResults.length === 0) return;
                
                // Move index based on direction
                if (forward) {
                    this.searchIndex = (this.searchIndex + 1) % this.searchResults.length;
                } else {
                    this.searchIndex = (this.searchIndex - 1 + this.searchResults.length) % this.searchResults.length;
                }
                
                this.updateSearchDisplay();
            }
            
            updateSearchPrompt() {
                const status = this.searchResults.length > 0 
                    ? `(${this.searchIndex + 1}/${this.searchResults.length})` 
                    : '(not found)';
                
                // Create a formatted string for consistent search prompt
                this.chatInput.value = `(reverse-i-search)${status}: ${this.searchTerm}`;
                
                // Store the position after the prompt for cursor positioning
                this.promptEndPosition = this.chatInput.value.indexOf(': ') + 2;
            }
            
            updateSearchDisplay() {
                if (this.searchIndex >= 0 && this.searchResults.length > 0) {
                    const status = `(${this.searchIndex + 1}/${this.searchResults.length})`;
                    const result = this.searchResults[this.searchIndex];
                    
                    // Show both the search term and the matched message with improved formatting
                    this.chatInput.value = `(reverse-i-search)${status}: ${this.searchTerm}  ${result}`;
                    this.currentInput = result;
                    
                    // Show the current matching result after hitting Enter/Tab
                    if (!this.searchMode) {
                        this.chatInput.value = result;
                    }
                } else {
                    this.updateSearchPrompt();
                }
                
                // If in search mode, maintain cursor position at end of search term
                if (this.searchMode) {
                    setTimeout(() => {
                        const cursorPos = this.promptEndPosition + this.searchTerm.length;
                        this.chatInput.selectionStart = this.chatInput.selectionEnd = cursorPos;
                    }, 0);
                }
            }

            closeChat() {
                this.isOpen = false;
                this.chatContainer.classList.remove('chat-open');
                
                // Start auto-fade timer when closing
                this.startAutoFadeTimer();
                
                console.log('Chat closed');
            }

            toggleChat() {
                if (this.isOpen) {
                    this.closeChat();
                } else {
                    this.openChat();
                }
            }

            toggleMinimize() {
                this.chatContainer.classList.toggle('minimized');
            }

            addMessage(content, timestamp = Date.now(), channel = 'global', messageType = null) {
                // If messageType is not provided, use channel as the type
                if (!messageType) {
                    messageType = channel;
                }
                
                const message = {
                    id: Date.now() + Math.random(),
                    content,
                    timestamp,
                    channel,
                    messageType
                };

                this.messages.push(message);
                this.lastMessageTime = Date.now();
                
                // Limit message count - when using flex-direction-reverse,
                // we still want to remove the oldest messages (first in array)
                if (this.messages.length > this.maxMessages) {
                    this.messages.shift();
                }

                // Show chat when message arrives
                this.showChat();
                
                // Check if this message is consumed by any tab
                let isConsumed = false;
                document.querySelectorAll('.chat-tab[data-consume="true"]').forEach(tab => {
                    if (tab.getAttribute('data-channel') !== this.activeChannel) {
                        // Check if this tab would show this message
                        const channelId = tab.getAttribute('data-channel');
                        if (this.shouldShowMessageInChannel(message, channelId)) {
                            // Mark tab as unread
                            if (!tab.classList.contains('active')) {
                                tab.classList.add('unread');
                            }
                            isConsumed = true;
                        }
                    }
                });

                // Only render the message if it belongs to the current channel based on filter criteria
                if (this.shouldShowMessageInChannel(message, this.activeChannel) && !isConsumed) {
                    this.renderMessage(message);
                    this.scrollToBottom();
                }

                // Start auto-fade timer
                this.startAutoFadeTimer();

                return message.id;
            }

            renderMessage(message) {
                const messageEl = document.createElement('div');
                messageEl.className = 'message new-message'; // Add new-message class for targeted animation
                messageEl.setAttribute('data-message-id', message.id);
                messageEl.setAttribute('data-timestamp', message.timestamp);
                messageEl.setAttribute('data-channel', message.channel || 'global');

                let html = '';

                // Include channel indicator for the 'all' channel view
                const channelIndicator = this.activeChannel === 'all' ? 
                    `<span class="channel-tag ${message.channel || 'global'}">[${(message.channel || 'global').toUpperCase()}]</span> ` : '';

                // Just the message content, Minecraft style
                html += `
                    <div class="message-content">${channelIndicator}${this.parseMessageContent(message.content)}</div>
                    <div class="message-reactions"></div>
                    <div class="message-timestamp">${this.formatTime(message.timestamp)}</div>
                    <div class="message-actions-toggle">
                        <span class="material-icons">more_vert</span>
                    </div>
                    <div class="message-actions-container">
                        <button class="message-action-btn" data-action="reply" title="Reply">
                            <span class="material-icons">reply</span>
                        </button>
                        <button class="message-action-btn" data-action="copy" title="Copy">
                            <span class="material-icons">content_copy</span>
                        </button>
                        <button class="message-action-btn" data-action="pin" title="Pin">
                            <span class="material-icons">push_pin</span>
                        </button>
                        <button class="message-action-btn" data-action="react" title="React">
                            <span class="material-icons">add_reaction</span>
                        </button>
                    </div>
                `;
                
                // Store the timestamp as data attribute for hover functionality
                messageEl.setAttribute('data-formatted-time', this.formatTime(message.timestamp));

                messageEl.innerHTML = html;
                
                // Directly insert the new message at the beginning of the message container
                // Only the new message will animate with the new-message class
                this.chatMessages.insertBefore(messageEl, this.chatMessages.firstChild);
                
                // Add hover event listeners for timestamp display
                messageEl.addEventListener('mouseenter', this.showTimestamp.bind(this, messageEl));
                messageEl.addEventListener('mouseleave', this.hideTimestamp.bind(this, messageEl));
                
                // Set up message actions
                this.setupMessageActions(messageEl);
                
                // Apply Twemoji to the message content
                try {
                    if (window.twemoji && typeof window.twemoji.parse === 'function') {
                        window.twemoji.parse(messageEl.querySelector('.message-content'));
                    }
                } catch (e) {
                    console.warn('Twemoji parsing failed:', e);
                }
                
                // Remove the new-message class after animation completes
                setTimeout(() => {
                    messageEl.classList.remove('new-message');
                }, 300);
            }
            
            showTimestamp(messageEl) {
                const content = messageEl.querySelector('.message-content');
                const timestamp = messageEl.querySelector('.message-timestamp');
                
                if (content && timestamp) {
                    content.classList.add('content-faded');
                    timestamp.classList.add('timestamp-visible');
                }
            }
            
            hideTimestamp(messageEl) {
                const content = messageEl.querySelector('.message-content');
                const timestamp = messageEl.querySelector('.message-timestamp');
                
                if (content && timestamp) {
                    content.classList.remove('content-faded');
                    timestamp.classList.remove('timestamp-visible');
                }
            }
            
            // Set up message actions and reactions
            setupMessageActions(messageEl) {
                const actionsToggle = messageEl.querySelector('.message-actions-toggle');
                const actionsContainer = messageEl.querySelector('.message-actions-container');
                
                // Toggle actions menu on click
                actionsToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    actionsContainer.classList.toggle('active');
                });
                
                // Set up action buttons
                const actionButtons = messageEl.querySelectorAll('.message-action-btn');
                actionButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = btn.getAttribute('data-action');
                        
                        switch(action) {
                            case 'reply':
                                this.replyToMessage(messageEl);
                                break;
                            case 'copy':
                                this.copyMessageContent(messageEl);
                                break;
                            case 'pin':
                                this.pinMessage(messageEl);
                                break;
                            case 'react':
                                                // Get the message ID
                                const messageId = messageEl.getAttribute('data-message-id');
                                // Open emoji picker for reaction
                                const emojiButton = messageEl.querySelector('[data-action="react"]');
                                // Ensure window.emojiPicker is available
                                if (window.emojiPicker && typeof window.emojiPicker.setupMessageButtons === 'function') {
                                    window.emojiPicker.setupMessageButtons();
                                    if (emojiButton) {
                                        // This will trigger the click handler in emoji-picker.js
                                        emojiButton.classList.add('message-action-emoji');
                                        emojiButton.click();
                                    }
                                }
                                break;
                        }
                    });
                });
                
                // Close menus when clicking elsewhere
                document.addEventListener('click', () => {
                    actionsContainer.classList.remove('active');
                });
                
                // Prevent clicks on menus from closing them
                actionsContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Use the DOM element rather than the JavaScript object
                const emojiPickerElement = document.getElementById('emoji-picker');
                if (emojiPickerElement) {
                    emojiPickerElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }
            }
            
            // Add reaction to a message
            addReaction(messageEl, emoji) {
                // Get the message ID
                const messageId = messageEl.getAttribute('data-message-id');
                
                // Use the emoji picker's add reaction function
                window.emojiPicker.addReaction(messageId, emoji);
                
                // Call the Java bridge to sync reactions if needed
                if (window.javabridge && typeof window.javabridge.onMessageReaction === 'function') {
                    window.javabridge.onMessageReaction(messageId, emoji, true);
                }
            }
            
            // Toggle a reaction (add/remove user)
            toggleReaction(reactionEl) {
                const messageEl = reactionEl.closest('.message');
                const messageId = messageEl.getAttribute('data-message-id');
                const emoji = reactionEl.getAttribute('data-emoji');
                const isActive = reactionEl.classList.contains('user-reacted');
                const count = parseInt(reactionEl.getAttribute('data-count') || '0', 10);
                
                // Use the emoji picker's toggle reaction function if available
                if (window.emojiPicker && typeof window.emojiPicker.toggleReaction === 'function') {
                    window.emojiPicker.toggleReaction(messageId, emoji);
                }
                
                if (isActive) {
                    // Remove reaction
                    if (count <= 1) {
                        reactionEl.parentNode.removeChild(reactionEl);
                    } else {
                        reactionEl.setAttribute('data-count', count - 1);
                        reactionEl.querySelector('.reaction-count').textContent = count - 1;
                        reactionEl.classList.remove('active');
                    }
                } else {
                    // Add reaction
                    reactionEl.setAttribute('data-count', count + 1);
                    reactionEl.querySelector('.reaction-count').textContent = count + 1;
                    reactionEl.classList.add('active');
                }
                
                // Call the Java bridge to sync reactions if needed
                if (window.javabridge && typeof window.javabridge.onMessageReaction === 'function') {
                    window.javabridge.onMessageReaction(messageId, emoji, !isActive);
                }
            }
            
            // Reply to a message
            replyToMessage(messageEl) {
                const messageId = messageEl.getAttribute('data-message-id');
                const content = messageEl.querySelector('.message-content').textContent;
                
                // Call the Java bridge to handle reply if needed
                if (window.javabridge && typeof window.javabridge.onMessageReply === 'function') {
                    window.javabridge.onMessageReply(messageId, content);
                }
                
                // Close the actions menu
                messageEl.querySelector('.message-actions-container').classList.remove('active');
            }
            
            // Copy message content to clipboard
            copyMessageContent(messageEl) {
                const content = messageEl.querySelector('.message-content').textContent;
                
                // Use the clipboard API to copy text
                navigator.clipboard.writeText(content).then(() => {
                    // Show a brief "copied" notification
                    this.showNotification('Message copied to clipboard');
                }).catch(err => {
                    console.error('Failed to copy message: ', err);
                });
                
                // Close the actions menu
                messageEl.querySelector('.message-actions-container').classList.remove('active');
            }
            
            // Pin a message
            pinMessage(messageEl) {
                const messageId = messageEl.getAttribute('data-message-id');
                const isPinned = messageEl.classList.contains('pinned');
                
                if (isPinned) {
                    messageEl.classList.remove('pinned');
                    
                    // Update message data
                    const messageIndex = this.messages.findIndex(m => m.id == messageId);
                    if (messageIndex !== -1) {
                        this.messages[messageIndex].isPinned = false;
                    }
                } else {
                    messageEl.classList.add('pinned');
                    
                    // Update message data
                    const messageIndex = this.messages.findIndex(m => m.id == messageId);
                    if (messageIndex !== -1) {
                        this.messages[messageIndex].isPinned = true;
                    }
                    
                    // Show unread indicator on pinned tab if not currently viewing it
                    if (this.activeChannel !== 'pinned') {
                        document.querySelector('.chat-tab[data-channel="pinned"]').classList.add('unread');
                    }
                }
                
                // Call the Java bridge to handle pinning if needed
                if (window.javabridge && typeof window.javabridge.onMessagePin === 'function') {
                    window.javabridge.onMessagePin(messageId, !isPinned);
                }
                
                // Close the actions menu
                messageEl.querySelector('.message-actions-container').classList.remove('active');
            }
            
            // Show a notification
            showNotification(message) {
                // Create notification element if it doesn't exist
                let notification = document.getElementById('notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'notification';
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.background = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '8px 16px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '9999';
                    notification.style.transition = 'opacity 0.3s ease';
                    notification.style.opacity = '0';
                    document.body.appendChild(notification);
                }
                
                // Set message and show notification
                notification.textContent = message;
                notification.style.opacity = '1';
                
                // Hide notification after a delay
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 2000);
            }
            
            // Get only the messages that are currently visible in the viewport
            getVisibleMessages() {
                const messages = Array.from(this.chatMessages.querySelectorAll('.message'));
                const containerRect = this.chatMessages.getBoundingClientRect();
                
                // Filter only visible messages to optimize performance
                return messages.filter(msg => {
                    const rect = msg.getBoundingClientRect();
                    // Check if the message is at least partially visible in the chat container
                    return (
                        rect.top < containerRect.bottom &&
                        rect.bottom > containerRect.top
                    );
                });
            }

            parseMessageContent(content) {
                // Replace line breaks with <br> tags
                content = content.replace(/\n/g, '<br>');
                
                // Replace URLs with clickable links
                content = content.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
                
                // No need to process emojis here as we use Twemoji.parse after rendering
                return content;
            }

            formatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            fadeMessage(messageId) {
                const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageEl) {
                    messageEl.classList.add('fade-out');
                    setTimeout(() => {
                        if (messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                        
                        // Remove message from array
                        this.messages = this.messages.filter(m => m.id != messageId);
                        
                        // If no messages left, hide chat completely
                        if (this.messages.length === 0 && !this.isOpen) {
                            this.hideChat();
                        }
                    }, 300);
                }
            }

            startAutoFadeTimer() {
                // Clear existing timer
                if (this.fadeTimeout) {
                    clearTimeout(this.fadeTimeout);
                }

                // If chat is open, don't fade
                if (this.isOpen) {
                    return;
                }

                // Start new timer for 10 seconds
                this.fadeTimeout = setTimeout(() => {
                    this.hideChat();
                }, 10000);
            }

            showChat() {
                this.chatContainer.classList.add('visible');
            }

            hideChat() {
                // Only hide if chat is not open and there are no messages or enough time has passed
                if (!this.isOpen) {
                    this.chatContainer.classList.remove('visible');
                }
            }

            // No longer needed reaction and reply methods - removed for Minecraft style chat

            sendMessage() {
                const content = this.chatInput.value.trim();
                const hasAttachment = this.currentAttachment !== null;
                
                if (!content && !hasAttachment) return;
                
                // Initialize history array if it doesn't exist
                if (!this.messageHistory) {
                    this.messageHistory = [];
                }

                // Add to message history (avoid duplicates at the end) - only for text content
                if (content && (this.messageHistory.length === 0 || this.messageHistory[this.messageHistory.length - 1] !== content)) {
                    this.messageHistory.push(content);
                    // Limit history size (e.g., keep last 50 messages)
                    if (this.messageHistory.length > 50) {
                        this.messageHistory.shift();
                    }
                    
                    // Save to localStorage for persistence
                    try {
                        localStorage.setItem('sequoiaChatHistory', JSON.stringify(this.messageHistory));
                    } catch (e) {
                        console.error('Error saving chat history', e);
                    }
                }
                
                // Reset history navigation
                this.historyIndex = -1;
                this.currentInput = '';

                // Add message to chat UI
                this.addMessage(content);
                this.chatInput.value = '';
                
                // Reset textarea height after sending
                this.chatInput.style.height = 'auto';
                
                // Send the message to Java/Minecraft
                if (window.javabridge) {
                    if (hasAttachment) {
                        // If there's an attachment, send it with the message
                        if (window.javabridge.sendMessageWithAttachment) {
                            // Send both content and attachment info to Java
                            window.javabridge.sendMessageWithAttachment(content, JSON.stringify(this.currentAttachment));
                        } else {
                            // Fallback if the attachment method isn't implemented
                            console.warn('sendMessageWithAttachment not implemented in Java bridge');
                            window.javabridge.sendMessage(content);
                        }
                        
                        // Clear the attachment after sending
                        this.removeAttachmentPreview();
                    } else {
                        // Just send the text message
                        window.javabridge.sendMessage(content);
                    }
                }
            }

            scrollToBottom() {
                // In reversed mode, scrolling to the "bottom" means scrolling to the top
                this.chatMessages.scrollTop = 0;
            }
            
            // Attachment handling
            handleFileSelected(fileInfo) {
                // This function will be called from Java
                // fileInfo should be an object with: { name, size, type, url, id }
                
                this.currentAttachment = fileInfo;
                this.showAttachmentPreview(fileInfo);
            }
            
            // For simulating attachment in browser testing
            simulateFileAttachment() {
                // Mock file object for testing
                const mockFile = {
                    name: 'test-image.png',
                    size: 1024 * 1024, // 1MB
                    type: 'image/png',
                    url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5QMJDRcX9NldZQAACaRJREFUeNrt3UuMVOUBh/Hz38vMDDOFmUEGsGAEVwWESEwamUkhJoxpJLrSdFNlYdt0YULSLppYJdXoqt2xaXDTxF1dNG1M2iab2ppopD7wEfEFFgXBqCAIDMPAzJy/i6lFZMY5Z86c///93x4zvl9y3nd+998AdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgUiZebLweZPaJJCm0ZxePufNijLEmhNj1/oW9vZLU3NPc1d9qfvThtQ9f91ApyS+59ZzRnyyRJPV8rOtf/fXYp1J6ZSDNvxTS3CzrHwEAuUzd30nWXAAAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCwSoMBALBGfxEAsEqDAQCwRn8RALBKgwEAsEZ/EQCw6j9Hkpvfd9esnwAAAIxJREFUeJxjYBgFo2AUjIJRMApGwSgYBaNgFIyCUTAKRsEoGAWjYBSMglEwCkbBKBgFo2AUjIJRMApGwSgYBaNgFIyCUTAKRsEoGAWjYBSMglEwCkbBKBgFo2AUjIJRMApGwSgYBaNgFIyCUTAKRsEoGAWjYBSMglEwCkbBKBgFo2AUjIJRMApGAaUAAAdXUZE/IDabAAAAAElFTkSuQmCC',
                    id: 'mock-file-' + Date.now()
                };
                
                this.handleFileSelected(mockFile);
            }
            
            showAttachmentPreview(fileInfo) {
                // Remove any existing preview
                this.removeAttachmentPreview();
                
                // Create attachment preview container
                const previewContainer = document.createElement('div');
                previewContainer.className = 'attachment-preview-container';
                previewContainer.id = 'attachment-preview';
                
                const preview = document.createElement('div');
                preview.className = 'attachment-preview';
                
                // Create remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'attachment-remove';
                removeBtn.textContent = '';
                removeBtn.addEventListener('click', () => this.removeAttachmentPreview());
                
                preview.appendChild(removeBtn);
                
                // Check if it's an image
                if (fileInfo.type && fileInfo.type.startsWith('image/')) {
                    // Create image preview
                    const img = document.createElement('img');
                    img.className = 'attachment-preview-img';
                    img.src = fileInfo.url;
                    img.alt = fileInfo.name;
                    preview.appendChild(img);
                } else {
                    // Create file preview
                    const filePreview = document.createElement('div');
                    filePreview.className = 'attachment-preview-file';
                    
                    // Icon based on file type
                    const icon = document.createElement('span');
                    icon.className = 'material-icons';
                    
                    if (fileInfo.type && fileInfo.type.startsWith('video/')) {
                        icon.textContent = 'videocam';
                    } else if (fileInfo.type && fileInfo.type.startsWith('audio/')) {
                        icon.textContent = 'audiotrack';
                    } else if (fileInfo.type && fileInfo.type.includes('pdf')) {
                        icon.textContent = 'picture_as_pdf';
                    } else {
                        icon.textContent = 'insert_drive_file';
                    }
                    
                    const fileInfo_elem = document.createElement('div');
                    fileInfo_elem.className = 'attachment-file-info';
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'attachment-file-name';
                    fileName.textContent = fileInfo.name;
                    
                    const fileSize = document.createElement('div');
                    fileSize.className = 'attachment-file-size';
                    fileSize.textContent = this.formatFileSize(fileInfo.size);
                    
                    fileInfo_elem.appendChild(fileName);
                    fileInfo_elem.appendChild(fileSize);
                    
                    filePreview.appendChild(icon);
                    filePreview.appendChild(fileInfo_elem);
                    preview.appendChild(filePreview);
                }
                
                previewContainer.appendChild(preview);
                
                // Add to input wrapper before the text input
                const chatInputWrapper = document.querySelector('.chat-input-wrapper');
                if (chatInputWrapper) {
                    // Insert before the text input
                    chatInputWrapper.insertBefore(previewContainer, this.chatInput);
                } else {
                    // Fallback to old method if wrapper not found
                    this.chatInput.parentNode.insertBefore(previewContainer, this.chatInput);
                }
            }
            
            removeAttachmentPreview() {
                const existingPreview = document.getElementById('attachment-preview');
                if (existingPreview) {
                    existingPreview.parentNode.removeChild(existingPreview);
                }
                this.currentAttachment = null;
                
                // Reset any styles we might have changed
                const chatInputWrapper = document.querySelector('.chat-input-wrapper');
                if (chatInputWrapper) {
                    // Ensure the wrapper doesn't keep any dynamic height changes
                    chatInputWrapper.style.height = '';
                }
            }
            
            formatFileSize(bytes) {
                if (bytes < 1024) {
                    return bytes + ' B';
                } else if (bytes < 1024 * 1024) {
                    return (bytes / 1024).toFixed(1) + ' KB';
                } else if (bytes < 1024 * 1024 * 1024) {
                    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                } else {
                    return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
                }
            }
            
            showToast(message) {
                const toast = document.createElement('div');
                toast.className = 'chat-toast';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                // Fade in
                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);
                
                // Remove after timeout
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            // Dragging
            startDrag(e) {
                if (e.target.closest('.chat-control-btn')) return;
                
                this.isDragging = true;
                
                // Store the starting position and mouse coordinates
                this.dragStart = {
                    left: this.settings.left,
                    top: this.settings.top,
                    mouseX: e.clientX,
                    mouseY: e.clientY
                };
                
                e.preventDefault();
            }

            // Resizing
            startResize(e) {
                this.isResizing = true;
                this.resizeDirection = e.target.dataset.direction;
                
                // Store the starting dimensions of the container
                this.resizeStart = {
                    width: this.settings.width,
                    height: this.settings.height,
                    left: this.settings.left,
                    top: this.settings.top,
                    mouseX: e.clientX,
                    mouseY: e.clientY
                };
                
                e.preventDefault();
            }

            onMouseMove(e) {
                // Get current browser dimensions for boundary checking
                const browserWidth = window.innerWidth;
                const browserHeight = window.innerHeight;
                
                if (this.isDragging) {
                    // Calculate the new position
                    const dx = e.clientX - this.dragStart.mouseX;
                    const dy = e.clientY - this.dragStart.mouseY;
                    
                    // Calculate potential new position
                    let newLeft = this.dragStart.left + dx;
                    let newTop = this.dragStart.top + dy;
                    
                    // Apply edge padding constraints
                    // Left edge boundary
                    newLeft = Math.max(this.edgePadding, newLeft);
                    // Top edge boundary
                    newTop = Math.max(this.edgePadding, newTop);
                    // Right edge boundary (considering container width)
                    newLeft = Math.min(browserWidth - this.settings.width - this.edgePadding, newLeft);
                    // Bottom edge boundary (considering container height)
                    newTop = Math.min(browserHeight - this.settings.height - this.edgePadding, newTop);
                    
                    // Update the position
                    this.settings.left = newLeft;
                    this.settings.top = newTop;
                    
                    // Apply the new position
                    this.chatContainer.style.left = `${this.settings.left}px`;
                    this.chatContainer.style.top = `${this.settings.top}px`;
                    
                } else if (this.isResizing) {
                    const direction = this.resizeDirection;
                    const dx = e.clientX - this.resizeStart.mouseX;
                    const dy = e.clientY - this.resizeStart.mouseY;
                    
                    // Starting values from where resize began
                    let newWidth = this.resizeStart.width;
                    let newHeight = this.resizeStart.height;
                    let newLeft = this.resizeStart.left;
                    let newTop = this.resizeStart.top;
                    
                    // Simple, direct resizing logic
                    if (direction.includes('e')) {
                        newWidth += dx;
                    } else if (direction.includes('w')) {
                        newWidth -= dx;
                        newLeft += dx;
                    }
                    
                    if (direction.includes('s')) {
                        newHeight += dy;
                    } else if (direction.includes('n')) {
                        newHeight -= dy;
                        newTop += dy;
                    }
                    
                    // Calculate constraints
                    const minWidth = 200;
                    const minHeight = 150;
                    const maxWidth = browserWidth - this.edgePadding * 2;
                    const maxHeight = browserHeight - this.edgePadding * 2;
                    
                    // Apply minimum dimensions
                    if (newWidth < minWidth) {
                        if (direction.includes('w')) {
                            newLeft -= (minWidth - newWidth);
                        }
                        newWidth = minWidth;
                    }
                    
                    if (newHeight < minHeight) {
                        if (direction.includes('n')) {
                            newTop -= (minHeight - newHeight);
                        }
                        newHeight = minHeight;
                    }
                    
                    // Apply maximum dimensions
                    if (newWidth > maxWidth) {
                        if (direction.includes('w')) {
                            // Adjust left position to maintain the right edge position
                            newLeft += (newWidth - maxWidth);
                        }
                        newWidth = maxWidth;
                    }
                    
                    if (newHeight > maxHeight) {
                        if (direction.includes('n')) {
                            // Adjust top position to maintain the bottom edge position
                            newTop += (newHeight - maxHeight);
                        }
                        newHeight = maxHeight;
                    }
                    
                    // Ensure the chat stays within browser boundaries
                    // Left edge constraint
                    if (newLeft < this.edgePadding) {
                        if (direction.includes('w')) {
                            // If resizing from the west, adjust the width
                            newWidth -= (this.edgePadding - newLeft);
                        }
                        newLeft = this.edgePadding;
                    }
                    
                    // Top edge constraint
                    if (newTop < this.edgePadding) {
                        if (direction.includes('n')) {
                            // If resizing from the north, adjust the height
                            newHeight -= (this.edgePadding - newTop);
                        }
                        newTop = this.edgePadding;
                    }
                    
                    // Right edge constraint
                    if (newLeft + newWidth > browserWidth - this.edgePadding) {
                        if (direction.includes('e')) {
                            // If resizing from the east, adjust the width
                            newWidth = browserWidth - this.edgePadding - newLeft;
                        }
                    }
                    
                    // Bottom edge constraint
                    if (newTop + newHeight > browserHeight - this.edgePadding) {
                        if (direction.includes('s')) {
                            // If resizing from the south, adjust the height
                            newHeight = browserHeight - this.edgePadding - newTop;
                        }
                    }
                    
                    // Update settings and apply new dimensions
                    this.settings.width = newWidth;
                    this.settings.height = newHeight;
                    this.settings.left = newLeft;
                    this.settings.top = newTop;
                    
                    // Apply styles directly
                    this.chatContainer.style.width = `${newWidth}px`;
                    this.chatContainer.style.height = `${newHeight}px`;
                    this.chatContainer.style.left = `${newLeft}px`;
                    this.chatContainer.style.top = `${newTop}px`;
                }
            }
            
            // Methods for adding new chat categories
            showAddCategoryDialog() {
                // Create modal for adding new chat category
                const modal = document.createElement('div');
                modal.className = 'chat-modal';
                modal.innerHTML = `
                    <div class="chat-modal-content">
                        <h3>Add New Chat Category</h3>
                        <div class="form-group">
                            <label for="categoryName">Name:</label>
                            <input type="text" id="categoryName" placeholder="Category name" maxlength="20">
                        </div>
                        <div class="form-group">
                            <label for="categoryIcon">Icon:</label>
                            <select id="categoryIcon">
                                <option value="chat">chat</option>
                                <option value="tag">tag</option>
                                <option value="group">group</option>
                                <option value="notifications">notifications</option>
                                <option value="favorite">favorite</option>
                                <option value="star">star</option>
                                <option value="language">language</option>
                                <option value="public">public</option>
                                <option value="forum">forum</option>
                                <option value="flag">flag</option>
                            </select>
                            <span id="iconPreview" class="material-icons">chat</span>
                        </div>
                        <div class="form-actions">
                            <button id="cancelAddCategory">Cancel</button>
                            <button id="confirmAddCategory">Add</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('categoryIcon').addEventListener('change', (e) => {
                    document.getElementById('iconPreview').textContent = e.target.value;
                });
                
                document.getElementById('cancelAddCategory').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                document.getElementById('confirmAddCategory').addEventListener('click', () => {
                    const name = document.getElementById('categoryName').value.trim();
                    const icon = document.getElementById('categoryIcon').value;
                    
                    if (name) {
                        this.addNewCategory(name, icon);
                        document.body.removeChild(modal);
                    } else {
                        alert('Please enter a category name');
                    }
                });
            }
            
            addNewCategory(name, icon) {
                console.log(`Adding new category: ${name} with icon: ${icon}`);
                
                // Create a safe channel ID from the name
                const channelId = name.toLowerCase().replace(/[^a-z0-9]/g, '-');
                
                // Check if this channel already exists
                if (document.querySelector(`.chat-tab[data-channel="${channelId}"]`)) {
                    alert(`A channel with the name "${name}" already exists.`);
                    return;
                }
                
                // Create new tab element
                const tabElement = document.createElement('button');
                tabElement.className = 'chat-tab';
                tabElement.setAttribute('data-channel', channelId);
                tabElement.innerHTML = `
                    <span class="material-icons">${icon}</span>
                    <span class="tab-name">${name}</span>
                `;
                
                // Add it before the add button (inside chat-tabs)
                const chatTabs = document.querySelector('.chat-tabs');
                chatTabs.appendChild(tabElement);
                
                // Add event listener
                tabElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.switchChannel(channelId);
                });
                
                // Switch to the new channel
                this.switchChannel(channelId);
                
                // Store custom channels in localStorage for persistence
                this.saveCustomChannels();
            }
            
            saveCustomChannels() {
                const customChannels = [];
                document.querySelectorAll('.chat-tab[data-channel]:not([data-channel="all"]):not([data-channel="global"]):not([data-channel="guild"]):not([data-channel="party"]):not([data-channel="private"]):not([data-channel="tab-config"])').forEach(tab => {
                    const channelId = tab.getAttribute('data-channel');
                    const channel = {
                        name: tab.querySelector('.tab-name').textContent,
                        icon: tab.querySelector('.material-icons').textContent,
                        id: channelId,
                        autoCommand: tab.getAttribute('data-auto-command') || '',
                        messageTypes: {
                            info: tab.getAttribute('data-msg-info') === 'true',
                            clientside: tab.getAttribute('data-msg-clientside') === 'true',
                            npc: tab.getAttribute('data-msg-npc') === 'true',
                            global: tab.getAttribute('data-msg-global') === 'true',
                            local: tab.getAttribute('data-msg-local') === 'true',
                            guild: tab.getAttribute('data-msg-guild') === 'true',
                            party: tab.getAttribute('data-msg-party') === 'true',
                            private: tab.getAttribute('data-msg-private') === 'true',
                            shout: tab.getAttribute('data-msg-shout') === 'true',
                            pets: tab.getAttribute('data-msg-pets') === 'true',
                            gameMessage: tab.getAttribute('data-msg-gameMessage') === 'true'
                        },
                        consumeMessages: tab.getAttribute('data-consume') === 'true',
                        filterPattern: tab.getAttribute('data-filter') || ''
                    };
                    customChannels.push(channel);
                });
                
                localStorage.setItem('sequoia2-custom-chat-channels', JSON.stringify(customChannels));
            }
            
            loadCustomChannels() {
                const savedChannels = localStorage.getItem('sequoia2-custom-chat-channels');
                if (savedChannels) {
                    try {
                        const customChannels = JSON.parse(savedChannels);
                        customChannels.forEach(channel => {
                            // Create new tab element
                            const tabElement = document.createElement('button');
                            tabElement.className = 'chat-tab';
                            tabElement.setAttribute('data-channel', channel.id);
                            
                            // Store additional attributes for the enhanced tab functionality
                            if (channel.autoCommand) {
                                tabElement.setAttribute('data-auto-command', channel.autoCommand);
                            }
                            
                            // Set message type flags
                            if (channel.messageTypes) {
                                tabElement.setAttribute('data-msg-info', channel.messageTypes.info || true);
                                tabElement.setAttribute('data-msg-clientside', channel.messageTypes.clientside || true);
                                tabElement.setAttribute('data-msg-npc', channel.messageTypes.npc || true);
                                tabElement.setAttribute('data-msg-global', channel.messageTypes.global || true);
                                tabElement.setAttribute('data-msg-local', channel.messageTypes.local || true);
                                tabElement.setAttribute('data-msg-guild', channel.messageTypes.guild || true);
                                tabElement.setAttribute('data-msg-party', channel.messageTypes.party || true);
                                tabElement.setAttribute('data-msg-private', channel.messageTypes.private || true);
                                tabElement.setAttribute('data-msg-shout', channel.messageTypes.shout || true);
                                tabElement.setAttribute('data-msg-pets', channel.messageTypes.pets || true);
                                tabElement.setAttribute('data-msg-gameMessage', channel.messageTypes.gameMessage || true);
                            }
                            
                            if (channel.consumeMessages) {
                                tabElement.setAttribute('data-consume', channel.consumeMessages);
                            }
                            
                            if (channel.filterPattern) {
                                tabElement.setAttribute('data-filter', channel.filterPattern);
                            }
                            
                            tabElement.innerHTML = `
                                <span class="material-icons">${channel.icon}</span>
                                <span class="tab-name">${channel.name}</span>
                            `;
                            
                            // Add it before the add button (inside chat-tabs)
                            const chatTabs = document.querySelector('.chat-tabs');
                            chatTabs.appendChild(tabElement);
                            
                            // Add event listener
                            tabElement.addEventListener('click', (e) => {
                                e.stopPropagation();
                                this.switchChannel(channel.id);
                            });
                            
                            // Add context menu (right-click) event
                            tabElement.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                this.showTabContextMenu(e, channel.id);
                            });
                        });
                    } catch (e) {
                        console.error('Failed to load custom channels:', e);
                    }
                }
            }

            onMouseUp() {
                if (this.isDragging || this.isResizing) {
                    // Save all settings to localStorage
                    localStorage.setItem('sequoiaChatSettings', JSON.stringify(this.settings));
                }
                this.isDragging = false;
                this.isResizing = false;
            }

            updatePosition() {
                this.chatContainer.style.left = this.settings.left + 'px';
                this.chatContainer.style.top = this.settings.top + 'px';
            }

            updateSize() {
                this.chatContainer.style.width = this.settings.width + 'px';
                this.chatContainer.style.height = this.settings.height + 'px';
            }

            updateOpacity() {
                document.documentElement.style.setProperty('--chat-bg-opacity', this.settings.opacity);
            }

            updateFontSize() {
                this.chatMessages.style.fontSize = this.settings.fontSize + 'px';
            }

            // Settings
            openSettings() {
                document.getElementById('fontSizeRange').value = this.settings.fontSize;
                document.getElementById('opacityRange').value = this.settings.opacity;
                document.getElementById('widthRange').value = this.settings.width;
                document.getElementById('heightRange').value = this.settings.height;
                
                document.getElementById('fontSizeValue').textContent = this.settings.fontSize + 'px';
                document.getElementById('opacityValue').textContent = Math.round(this.settings.opacity * 100) + '%';
                document.getElementById('widthValue').textContent = this.settings.width + 'px';
                document.getElementById('heightValue').textContent = this.settings.height + 'px';
                
                this.settingsModal.classList.add('show');
            }

            closeSettings() {
                this.settingsModal.classList.remove('show');
            }

            saveSettings() {
                // Get values from sliders
                const fontSize = parseInt(document.getElementById('fontSizeRange').value);
                const opacity = parseFloat(document.getElementById('opacityRange').value);
                const width = parseInt(document.getElementById('widthRange').value);
                const height = parseInt(document.getElementById('heightRange').value);
                
                // Update only specific settings, don't touch position
                this.settings.fontSize = fontSize;
                this.settings.opacity = opacity;
                this.settings.width = width;
                this.settings.height = height;
                
                this.updateSize();
                this.updateOpacity();
                this.updateFontSize();
                this.closeSettings();
                
                // Save to localStorage
                localStorage.setItem('sequoiaChatSettings', JSON.stringify(this.settings));
            }

            loadSettings() {
                const saved = localStorage.getItem('sequoiaChatSettings');
                if (saved) {
                    this.settings = { ...this.settings, ...JSON.parse(saved) };
                    this.updateSize();
                    this.updateOpacity();
                    this.updateFontSize();
                    this.updatePosition();
                }
            }

            // External API for Java integration
            receiveMessage(content, timestamp, channel = 'global') {
                try {
                    console.log(`Receiving message in channel: ${channel}`);
                    
                    // Add the message with channel information
                    const message = {
                        content: content,
                        timestamp: timestamp || Date.now(),
                        channel: channel
                    };
                    
                    // Add the message to the chat
                    this.addMessage(message.content, message.timestamp, message.channel);
                    
                    // Update unread indicators if needed
                    if (this.activeChannel !== 'all' && this.activeChannel !== channel) {
                        // Add unread indicator to the channel
                        const channelTab = document.querySelector(`.chat-tab[data-channel="${channel}"]`);
                        if (channelTab) {
                            channelTab.classList.add('unread');
                        }
                    }
                } catch (error) {
                    console.error('Error receiving message:', error);
                }
            }
            
            switchChannel(channel) {
                try {
                    console.log(`Switching to channel: ${channel}`);
                    
                    // Special handling for tab-config channel
                    if (channel === 'tab-config') {
                        console.log('Detected tab-config channel, showing tab config UI directly');
                        
                        // Hide chat elements
                        const chatMessages = document.getElementById('chatMessages');
                        if (chatMessages) chatMessages.style.display = 'none';
                        
                        const chatInputContainer = document.getElementById('chatInputContainer');
                        if (chatInputContainer) chatInputContainer.style.display = 'none';
                        
                        // Show tab config with all styling
                        const tabConfigEl = document.getElementById('chatTabConfig');
                        if (tabConfigEl) {
                            console.log('Tab config element found, displaying it');
                            tabConfigEl.style.display = 'flex';
                            tabConfigEl.style.visibility = 'visible';
                            tabConfigEl.style.opacity = '1';
                            
                            // Also initialize tab config
                            this.showTabConfig();
                        } else {
                            console.error('Tab config element not found!');
                        }
                        
                        // Update current channel
                        this.currentChannel = channel;
                        return; // Exit early as we've handled tab-config specifically
                    }
                    
                    // Normal channel handling continues here
                    // First, hide both the chat messages area and tab config area
                    const messagesParent = document.getElementById('chatMessages')?.parentElement;
                    const tabConfigEl = document.getElementById('chatTabConfig');
                    
                    if (messagesParent) {
                        messagesParent.style.display = 'none';
                    } else {
                        console.warn('Chat messages parent element not found');
                    }
                    
                    if (tabConfigEl) {
                        tabConfigEl.style.display = 'none';
                    } else {
                        console.warn('Tab config element not found');
                    }
                    
                    // Get the chat input container
                    const chatInputContainer = document.querySelector('.chat-input-container');
                    
                    // Check if this is a readonly tab
                    const channelTab = document.querySelector(`.chat-tab[data-channel="${channel}"]`);
                    const isReadonlyTab = channelTab && channelTab.getAttribute('data-readonly') === 'true';
                    
                    // For all other channels, show the chat messages
                        if (messagesParent) {
                            messagesParent.style.display = 'flex';
                        }
                        
                        // Hide or show the chat input based on readonly status
                        if (chatInputContainer) {
                            chatInputContainer.style.display = isReadonlyTab ? 'none' : 'flex';
                        } else {
                            console.warn('Chat input container not found');
                        }
                        
                        // Clear the chat
                        const chatContainer = document.getElementById('chatMessages');
                        if (chatContainer) {
                            chatContainer.innerHTML = '';
                            
                            // Load content based on the channel type
                            if (channel === 'pinned') {
                                this.loadPinnedMessages();
                                console.log('Loading pinned messages');
                            } else if (channel === 'bomb-bells') {
                                this.loadBombBellMessages();
                                console.log('Loading bomb bell messages');
                            } else if (channel === 'lfg') {
                                this.loadLFGMessages();
                                console.log('Loading LFG messages');
                            } else {
                                // Regular channel - show filtered messages
                                this.messages.forEach(message => {
                                    if (this.shouldShowMessageInChannel(message, channel)) {
                                        this.renderMessage(message);
                                    }
                                });
                            }
                        } else {
                            console.warn('Chat messages container not found');
                        }
                        
                        // Scroll to bottom
                        this.scrollToBottom();
                        
                        // Update the current channel
                        this.currentChannel = channel;
                    
                    // Remove active class from all channel buttons
                    const tabElements = document.querySelectorAll('.chat-tab');
                    if (tabElements) {
                        tabElements.forEach(item => {
                            if (item) {
                                item.classList.remove('active');
                            }
                        });
                    }
                    
                    // Add active class to the clicked channel button
                    if (channelTab) {
                        channelTab.classList.add('active');
                        
                        // Remove unread indicator
                        channelTab.classList.remove('unread');
                        
                        // Set the active channel
                        this.activeChannel = channel;
                        
                        // Update chat title
                        const tabNameElement = channelTab.querySelector('.tab-name');
                        const tabName = tabNameElement ? tabNameElement.textContent : 'Chat';
                        
                        const titleElement = document.querySelector('.chat-title');
                        if (titleElement) {
                            titleElement.innerText = tabName;
                        }
                        
                        // Execute auto command if present (but not for tab-config or readonly tabs)
                        if (channel !== 'tab-config' && !isReadonlyTab) {
                            const autoCommand = channelTab.getAttribute('data-auto-command');
                            if (autoCommand && autoCommand.trim() !== '') {
                                this.executeCommand(autoCommand);
                            }
                        }
                    } else {
                        console.warn(`Channel tab element not found for channel: ${channel}`);
                    }
                } catch (error) {
                    console.error('Error switching channel:', error);
                }
            }
            
            // Helper method for message filtering based on tab settings
            shouldShowMessageInChannel(message, channelId) {
                // The "all" tab always shows everything
                if (channelId === 'all') {
                    return true;
                }
                
                // For built-in channels, only show messages for that channel
                if (['global', 'guild', 'party', 'private'].includes(channelId)) {
                    return message.channel === channelId;
                }
                
                // Special channels have their own filtering logic
                if (['pinned', 'bomb-bells', 'lfg'].includes(channelId)) {
                    return false; // These channels don't automatically display messages
                }
                
                // Get the tab element for the channel
                const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                if (!tabElement) {
                    return false;
                }
                
                // Check if message type is enabled for this tab
                const messageType = message.channel || 'global';
                if (tabElement.getAttribute(`data-msg-${messageType}`) === 'false') {
                    return false;
                }
                
                // Check if the message matches the filter pattern (if any)
                const filterPattern = tabElement.getAttribute('data-filter');
                if (filterPattern && filterPattern.trim() !== '') {
                    try {
                        const regex = new RegExp(filterPattern);
                        if (!regex.test(message.content)) {
                            return false;
                        }
                    } catch (e) {
                        console.error('Invalid regex pattern:', e);
                        // If regex is invalid, don't filter based on it
                    }
                }
                
                return true;
            }
            
            // Load pinned messages
            loadPinnedMessages() {
                try {
                    const chatContainer = document.getElementById('chatMessages');
                    if (!chatContainer) {
                        console.error('Chat messages container not found when loading pinned messages');
                        return;
                    }
                    
                    // Find messages that are pinned
                    const pinnedMessages = this.messages ? this.messages.filter(message => 
                        message && message.isPinned === true
                    ) : [];
                    
                    console.log(`Found ${pinnedMessages.length} pinned messages`);
                    
                    if (pinnedMessages.length > 0) {
                        // Render pinned messages
                        pinnedMessages.forEach(message => {
                            this.renderMessage(message);
                        });
                    } else {
                        // Show placeholder message matching the screenshot design
                        const placeholder = document.createElement('div');
                        placeholder.className = 'message system empty-state-message';
                        placeholder.innerHTML = `
                            <div class="message-content">
                                <div style="text-align: center; padding: 30px 20px;">
                                    <div class="empty-state-icon">
                                        <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M14 4v5c0 .55.45 1 1 1h5M19 9L14 4M7 13h10v7H7v-7z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                        </svg>
                                    </div>
                                    <p style="margin-top: 10px; color: rgba(255,255,255,0.5);">No pinned messages yet</p>
                                    <p style="font-size: 12px; color: rgba(255,255,255,0.3);">Pin messages to see them here</p>
                                </div>
                            </div>
                        `;
                        chatContainer.appendChild(placeholder);
                    }
                } catch (error) {
                    console.error('Error loading pinned messages:', error);
                }
            }
            
            // Load bomb bell messages
            loadBombBellMessages() {
                try {
                    const chatContainer = document.getElementById('chatMessages');
                    if (!chatContainer) {
                        console.error('Chat messages container not found when loading bomb bell messages');
                        return;
                    }
                    
                    // Placeholder for bomb bell messages
                    const placeholder = document.createElement('div');
                    placeholder.className = 'message system empty-state-message';
                    placeholder.innerHTML = `
                        <div class="message-content">
                            <div style="text-align: center; padding: 30px 20px;">
                                <div class="empty-state-icon">
                                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M10 5a2 2 0 114 0 7 7 0 014 6v3a4 4 0 002 3H4a4 4 0 002-3v-3a7 7 0 014-6M9 17v1a3 3 0 006 0v-1" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                    </svg>
                                </div>
                                <p style="margin-top: 10px; color: rgba(255,255,255,0.5);">No bomb bell notifications</p>
                                <p style="font-size: 12px; color: rgba(255,255,255,0.3);">Notifications will appear here</p>
                            </div>
                        </div>
                    `;
                    chatContainer.appendChild(placeholder);
                    console.log('Added bomb bell placeholder message');
                } catch (error) {
                    console.error('Error loading bomb bell messages:', error);
                }
            }
            
            // Load LFG messages
            loadLFGMessages() {
                try {
                    const chatContainer = document.getElementById('chatMessages');
                    if (!chatContainer) {
                        console.error('Chat messages container not found when loading LFG messages');
                        return;
                    }
                    
                    // Placeholder for LFG messages
                    const placeholder = document.createElement('div');
                    placeholder.className = 'message system empty-state-message';
                    placeholder.innerHTML = `
                        <div class="message-content">
                            <div style="text-align: center; padding: 30px 20px;">
                                <div class="empty-state-icon">
                                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                    </svg>
                                </div>
                                <p style="margin-top: 10px; color: rgba(255,255,255,0.5);">No LFG requests</p>
                                <p style="font-size: 12px; color: rgba(255,255,255,0.3);">LFG requests will appear here</p>
                            </div>
                        </div>
                    `;
                    chatContainer.appendChild(placeholder);
                    console.log('Added LFG placeholder message');
                } catch (error) {
                    console.error('Error loading LFG messages:', error);
                }
            }
            
            // Execute a command (for auto-command feature)
            executeCommand(command) {
                if (!command || command.trim() === '') return;
                
                const inputField = document.getElementById('chatInput');
                const originalValue = inputField.value;
                
                // Set the command in the input field
                inputField.value = command;
                
                // Submit the command
                this.sendMessage();
                
                // Restore the original input value
                inputField.value = originalValue;
            }
            
            // Show the context menu for a tab
            showTabContextMenu(event, channelId) {
                // Don't show context menu for default tabs or readonly tabs
                if (['all', 'global', 'guild', 'party', 'private', 'pinned', 'bomb-bells', 'lfg'].includes(channelId)) {
                    return;
                }
                
                // Remove any existing context menu
                const existingMenu = document.querySelector('.tab-context-menu');
                if (existingMenu) {
                    existingMenu.remove();
                }
                
                // Create context menu
                const menu = document.createElement('div');
                menu.className = 'tab-context-menu';
                menu.innerHTML = `
                    <div class="tab-context-menu-item" data-action="edit">
                        <span class="material-icons">edit</span> Edit Tab
                    </div>
                    <div class="tab-context-menu-item" data-action="delete">
                        <span class="material-icons">delete</span> Delete Tab
                    </div>
                `;
                
                // Position the menu
                menu.style.left = `${event.clientX}px`;
                menu.style.top = `${event.clientY}px`;
                
                // Add event listeners
                menu.querySelector('[data-action="edit"]').addEventListener('click', () => {
                    this.openEditTabModal(channelId);
                    menu.remove();
                });
                
                menu.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    this.deleteTab(channelId);
                    menu.remove();
                });
                
                // Add click outside to close
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                });
                
                // Add to document
                document.body.appendChild(menu);
            }
            
            // Open the edit tab modal
            openEditTabModal(channelId) {
                const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                if (!tabElement) return;
                
                // Get tab data
                const tabName = tabElement.querySelector('.tab-name').textContent;
                const tabIcon = tabElement.querySelector('.material-icons').textContent;
                const autoCommand = tabElement.getAttribute('data-auto-command') || '';
                const consumeMessages = tabElement.getAttribute('data-consume') === 'true';
                const filterPattern = tabElement.getAttribute('data-filter') || '';
                
                // Set values in the edit modal
                document.getElementById('editChannelId').value = channelId;
                document.getElementById('editChannelName').value = tabName;
                document.getElementById('editChannelIcon').value = tabIcon;
                document.getElementById('editAutoCommand').value = autoCommand;
                document.getElementById('editConsumeMessages').checked = consumeMessages;
                document.getElementById('editFilterPattern').value = filterPattern;
                
                // Set message type checkboxes
                document.getElementById('editMsgTypeGlobal').checked = tabElement.getAttribute('data-msg-global') !== 'false';
                document.getElementById('editMsgTypeGuild').checked = tabElement.getAttribute('data-msg-guild') !== 'false';
                document.getElementById('editMsgTypeParty').checked = tabElement.getAttribute('data-msg-party') !== 'false';
                document.getElementById('editMsgTypePrivate').checked = tabElement.getAttribute('data-msg-private') !== 'false';
                document.getElementById('editMsgTypeSystem').checked = tabElement.getAttribute('data-msg-system') !== 'false';
                document.getElementById('editMsgTypeCombat').checked = tabElement.getAttribute('data-msg-combat') !== 'false';
                
                // Show the modal
                const modal = document.getElementById('editChannelModal');
                modal.style.display = 'flex';
                
                // Add close event to the X button
                modal.querySelector('.chat-modal-close').addEventListener('click', () => {
                    modal.style.display = 'none';
                });
                
                // Add update button handler
                document.getElementById('updateChannelBtn').addEventListener('click', () => {
                    this.updateTab(
                        channelId,
                        document.getElementById('editChannelName').value,
                        document.getElementById('editChannelIcon').value,
                        document.getElementById('editAutoCommand').value,
                        {
                            global: document.getElementById('editMsgTypeGlobal').checked,
                            guild: document.getElementById('editMsgTypeGuild').checked,
                            party: document.getElementById('editMsgTypeParty').checked,
                            private: document.getElementById('editMsgTypePrivate').checked,
                            system: document.getElementById('editMsgTypeSystem').checked,
                            combat: document.getElementById('editMsgTypeCombat').checked
                        },
                        document.getElementById('editConsumeMessages').checked,
                        document.getElementById('editFilterPattern').value
                    );
                    modal.style.display = 'none';
                });
                
                // Add delete button handler
                document.getElementById('deleteChannelBtn').addEventListener('click', () => {
                    this.deleteTab(channelId);
                    modal.style.display = 'none';
                });
            }
            
            // Update a tab with new settings
            updateTab(channelId, name, icon, autoCommand, messageTypes, consumeMessages, filterPattern) {
                const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                if (!tabElement) return;
                
                // Update visual elements
                tabElement.querySelector('.tab-name').textContent = name;
                tabElement.querySelector('.material-icons').textContent = icon;
                
                // Update data attributes
                tabElement.setAttribute('data-auto-command', autoCommand);
                tabElement.setAttribute('data-msg-global', messageTypes.global);
                tabElement.setAttribute('data-msg-guild', messageTypes.guild);
                tabElement.setAttribute('data-msg-party', messageTypes.party);
                tabElement.setAttribute('data-msg-private', messageTypes.private);
                tabElement.setAttribute('data-msg-system', messageTypes.system);
                tabElement.setAttribute('data-msg-combat', messageTypes.combat);
                tabElement.setAttribute('data-consume', consumeMessages);
                tabElement.setAttribute('data-filter', filterPattern);
                
                // Save changes
                this.saveCustomChannels();
                
                // If this is the active tab, refresh the display
                if (tabElement.classList.contains('active')) {
                    this.switchChannel(channelId);
                }
            }
            
            // Delete a tab
            deleteTab(channelId) {
                const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                if (!tabElement) return;
                
                // If this is the active tab, switch to 'all' first
                if (tabElement.classList.contains('active')) {
                    this.switchChannel('all');
                }
                
                // Remove the tab
                tabElement.remove();
                
                // Save changes
                this.saveCustomChannels();
            }
            
            // Create a new tab
            createNewTab(name, icon, autoCommand, messageTypes, consumeMessages, filterPattern) {
                if (!name || name.trim() === '') {
                    console.error('Tab name cannot be empty');
                    return;
                }
                
                // Generate a unique ID for the channel
                const channelId = 'custom_' + Date.now();
                
                // Create the tab element
                const tabElement = document.createElement('button');
                tabElement.className = 'chat-tab';
                tabElement.setAttribute('data-channel', channelId);
                
                // Set data attributes
                if (autoCommand) {
                    tabElement.setAttribute('data-auto-command', autoCommand);
                }
                
                tabElement.setAttribute('data-msg-global', messageTypes.global);
                tabElement.setAttribute('data-msg-guild', messageTypes.guild);
                tabElement.setAttribute('data-msg-party', messageTypes.party);
                tabElement.setAttribute('data-msg-private', messageTypes.private);
                tabElement.setAttribute('data-msg-system', messageTypes.system);
                tabElement.setAttribute('data-msg-combat', messageTypes.combat);
                
                tabElement.setAttribute('data-consume', consumeMessages);
                
                if (filterPattern) {
                    tabElement.setAttribute('data-filter', filterPattern);
                }
                
                tabElement.innerHTML = `
                    <span class="material-icons">${icon}</span>
                    <span class="tab-name">${name}</span>
                `;
                
                // Add it to the chat tabs
                const chatTabs = document.querySelector('.chat-tabs');
                chatTabs.appendChild(tabElement);
                
                // Add event listeners
                tabElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.switchChannel(channelId);
                });
                
                // Add context menu (right-click) event
                tabElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showTabContextMenu(e, channelId);
                });
                
                // Switch to the new channel
                this.switchChannel(channelId);
                
                // Store custom channels in localStorage for persistence
                this.saveCustomChannels();
            }
            
            // Communication bridge for Java
            sendChatMessage(message) {
                // This will be called by Java to send messages from the user
                if (window.javabridge && window.javabridge.sendMessage) {
                    window.javabridge.sendMessage(message);
                }
            }

            // Handle key events from Java
            handleKeyPress(key) {
                if (key === 'T' || key === 'Enter') {
                    this.openChat();
                    return true; // Consume the event
                } else if (key === 'Escape' && this.isOpen) {
                    this.closeChat();
                    return true; // Consume the event
                }
                return false; // Don't consume the event
            }
            
            // Show tab configuration screen
            showTabConfig() {
                try {
                    console.log('Showing tab configuration screen');
                    
                    // Hide the main chat interface
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.style.display = 'none';
                    } else {
                        console.warn('Chat messages element not found');
                    }
                    
                    const chatInputContainer = document.getElementById('chatInputContainer');
                    if (chatInputContainer) {
                        chatInputContainer.style.display = 'none';
                    } else {
                        console.warn('Chat input container element not found');
                    }
                    
                    // Show tab config
                    const tabConfigEl = document.getElementById('chatTabConfig');
                    if (tabConfigEl) {
                        // Debug info
                        console.log('Tab config element found:', tabConfigEl);
                        
                        // Make sure it's visible and properly displayed
                        tabConfigEl.style.display = 'flex';
                        tabConfigEl.style.opacity = '1';
                        tabConfigEl.style.visibility = 'visible';
                        
                        // Force a redraw
                        setTimeout(() => {
                            console.log('Forcing redraw of tab config');
                            tabConfigEl.style.display = 'none';
                            void tabConfigEl.offsetHeight; // Force reflow
                            tabConfigEl.style.display = 'flex';
                        }, 10);
                        
                        console.log('Tab config element shown with display: flex');
                        
                        // Set up message type checkbox behavior
                        this.setupMessageTypeCheckboxes();
                    } else {
                        console.error('Tab config element not found - cannot show tab configuration');
                        return; // Exit early if we can't show the tab config
                    }
                    
                    // Clear fields and set defaults for new tab
                    const tabConfigTitle = document.getElementById('tabConfigTitle');
                    if (tabConfigTitle) {
                        tabConfigTitle.textContent = 'Create New Tab';
                    }
                    
                    const channelId = document.getElementById('channelId');
                    if (channelId) {
                        channelId.value = '';
                    }
                    
                    const channelName = document.getElementById('channelName');
                    if (channelName) {
                        channelName.value = '';
                    }
                    
                    const autoCommand = document.getElementById('autoCommand');
                    if (autoCommand) {
                        autoCommand.value = '';
                    }
                    
                    const channelOrder = document.getElementById('channelOrder');
                    if (channelOrder) {
                        channelOrder.value = '1';
                    }
                    
                    const filterPattern = document.getElementById('filterPattern');
                    if (filterPattern) {
                        filterPattern.value = '';
                    }
                    
                    const consumeMessages = document.getElementById('consumeMessages');
                    if (consumeMessages) {
                        consumeMessages.checked = false;
                    }
                    
                    // Check default message types - add null checks for each checkbox
                    const msgTypeInfo = document.getElementById('msgTypeInfo');
                    if (msgTypeInfo) {
                        msgTypeInfo.checked = true;
                    }
                    
                    const msgTypeClientside = document.getElementById('msgTypeClientside');
                    if (msgTypeClientside) {
                        msgTypeClientside.checked = true;
                    }
                    
                    const msgTypeNPC = document.getElementById('msgTypeNPC');
                    if (msgTypeNPC) {
                        msgTypeNPC.checked = true;
                    }
                    
                    const msgTypeGlobal = document.getElementById('msgTypeGlobal');
                    if (msgTypeGlobal) {
                        msgTypeGlobal.checked = true;
                    }
                    
                    const msgTypeLocal = document.getElementById('msgTypeLocal');
                    if (msgTypeLocal) {
                        msgTypeLocal.checked = true;
                    }
                    
                    const msgTypeGuild = document.getElementById('msgTypeGuild');
                    if (msgTypeGuild) {
                        msgTypeGuild.checked = true;
                    }
                    
                    const msgTypeParty = document.getElementById('msgTypeParty');
                    if (msgTypeParty) {
                        msgTypeParty.checked = true;
                    }
                    
                    const msgTypePrivate = document.getElementById('msgTypePrivate');
                    if (msgTypePrivate) {
                        msgTypePrivate.checked = true;
                    }
                    
                    const msgTypeShout = document.getElementById('msgTypeShout');
                    if (msgTypeShout) {
                        msgTypeShout.checked = true;
                    }
                    
                    const msgTypePets = document.getElementById('msgTypePets');
                    if (msgTypePets) {
                        msgTypePets.checked = true;
                    }
                    
                    const msgTypeGameMessage = document.getElementById('msgTypeGameMessage');
                    if (msgTypeGameMessage) {
                        msgTypeGameMessage.checked = true;
                    }
                    
                    // Set up event listeners
                    this.setupTabConfigEventListeners();
                } catch (error) {
                    console.error('Error showing tab config:', error);
                }
            }
            
            // Setup message type checkboxes behavior
            setupMessageTypeCheckboxes() {
                try {
                    console.log('Setting up message type checkboxes behavior');
                    
                    // Get all message type checkboxes
                    const checkboxes = document.querySelectorAll('.message-type-checkbox input[type="checkbox"]');
                    
                    // Update active state based on checked status
                    const updateActiveState = (checkbox) => {
                        const parent = checkbox.closest('.message-type-checkbox');
                        if (parent) {
                            if (checkbox.checked) {
                                parent.classList.add('active');
                            } else {
                                parent.classList.remove('active');
                            }
                        }
                    };
                    
                    // Initialize state for all checkboxes
                    checkboxes.forEach(checkbox => {
                        updateActiveState(checkbox);
                        
                        // Add change event listener
                        checkbox.addEventListener('change', () => {
                            updateActiveState(checkbox);
                        });
                    });
                } catch (error) {
                    console.error('Error setting up message type checkboxes:', error);
                }
            }
            
            // Set up event listeners for tab config
            setupTabConfigEventListeners() {
                try {
                    console.log('Setting up tab config event listeners');
                    
                    const saveBtn = document.getElementById('saveTabBtn');
                    const saveAndCloseBtn = document.getElementById('saveAndCloseTabBtn');
                    const cancelBtn = document.getElementById('cancelTabBtn');
                    const closeTabConfigBtn = document.getElementById('closeTabConfigBtn');
                    
                    // Check if buttons exist before trying to access them
                    if (!saveBtn || !saveAndCloseBtn || !cancelBtn) {
                        console.error('One or more tab config buttons not found');
                        return;
                    }
                    
                    // Setup tab config header for dragging
                    const tabConfigHeader = document.getElementById('tabConfigHeader');
                    if (tabConfigHeader) {
                        // Make sure the header triggers the same drag functionality as the main chat header
                        tabConfigHeader.addEventListener('mousedown', (e) => this.startDrag(e));
                    }
                    
                    // Setup close button
                    if (closeTabConfigBtn) {
                        closeTabConfigBtn.addEventListener('click', () => {
                            const tabConfigEl = document.getElementById('chatTabConfig');
                            if (tabConfigEl) {
                                tabConfigEl.style.display = 'none';
                            }
                        });
                    }
                    
                    // Remove existing event listeners
                    const newSaveBtn = saveBtn.cloneNode(true);
                    const newSaveAndCloseBtn = saveAndCloseBtn.cloneNode(true);
                    const newCancelBtn = cancelBtn.cloneNode(true);
                    
                    saveBtn.replaceWith(newSaveBtn);
                    saveAndCloseBtn.replaceWith(newSaveAndCloseBtn);
                    cancelBtn.replaceWith(newCancelBtn);
                    
                    // Add new event listeners
                    const updatedSaveBtn = document.getElementById('saveTabBtn');
                    if (updatedSaveBtn) {
                        updatedSaveBtn.addEventListener('click', () => {
                            this.saveTabConfig(false);
                        });
                    }
                    
                    const updatedSaveAndCloseBtn = document.getElementById('saveAndCloseTabBtn');
                    if (updatedSaveAndCloseBtn) {
                        updatedSaveAndCloseBtn.addEventListener('click', () => {
                            this.saveTabConfig(true);
                        });
                    }
                    
                    const updatedCancelBtn = document.getElementById('cancelTabBtn');
                    if (updatedCancelBtn) {
                        updatedCancelBtn.addEventListener('click', () => {
                            this.closeTabConfig();
                        });
                    }
                } catch (error) {
                    console.error('Error setting up tab config event listeners:', error);
                }
            }
            
            // Save tab configuration
            saveTabConfig(shouldClose) {
                try {
                    console.log('Saving tab configuration');
                    
                    // Get form values with null checks
                    const channelIdElement = document.getElementById('channelId');
                    const channelId = channelIdElement ? channelIdElement.value : '';
                    
                    const channelNameElement = document.getElementById('channelName');
                    const name = channelNameElement ? channelNameElement.value.trim() : '';
                    
                    const autoCommandElement = document.getElementById('autoCommand');
                    const autoCommand = autoCommandElement ? autoCommandElement.value.trim() : '';
                    
                    const channelOrderElement = document.getElementById('channelOrder');
                    const order = channelOrderElement ? (parseInt(channelOrderElement.value) || 1) : 1;
                    
                    const consumeMessagesElement = document.getElementById('consumeMessages');
                    const consumeMessages = consumeMessagesElement ? consumeMessagesElement.checked : false;
                    
                    const filterPatternElement = document.getElementById('filterPattern');
                    const filterPattern = filterPatternElement ? filterPatternElement.value.trim() : '';
                    
                    // Validate name
                    if (!name) {
                        alert('Tab name is required!');
                        return;
                    }
                    
                    // Get message types and update checkbox styling
                    const messageTypes = {
                        info: document.getElementById('msgTypeInfo')?.checked || false,
                        clientside: document.getElementById('msgTypeClientside')?.checked || false,
                        npc: document.getElementById('msgTypeNPC')?.checked || false,
                        global: document.getElementById('msgTypeGlobal')?.checked || false,
                        local: document.getElementById('msgTypeLocal')?.checked || false,
                        guild: document.getElementById('msgTypeGuild')?.checked || false,
                        party: document.getElementById('msgTypeParty')?.checked || false,
                        private: document.getElementById('msgTypePrivate')?.checked || false,
                        shout: document.getElementById('msgTypeShout')?.checked || false,
                        pets: document.getElementById('msgTypePets')?.checked || false,
                        gameMessage: document.getElementById('msgTypeGameMessage')?.checked || false
                    };
                    
                    // Check if at least one message type is selected
                    if (!Object.values(messageTypes).some(v => v === true)) {
                        alert('Please select at least one message type!');
                        return;
                    }
                    
                    // If channelId is empty, it's a new tab
                    if (!channelId) {
                        this.createNewTab(name, 'tag', autoCommand, messageTypes, consumeMessages, filterPattern, order);
                    } else {
                        this.updateTab(channelId, name, 'tag', autoCommand, messageTypes, consumeMessages, filterPattern, order);
                    }
                    
                    // Close if requested
                    if (shouldClose) {
                        this.closeTabConfig();
                    } else if (!channelId) {
                        // Reset for another new tab
                        if (channelNameElement) channelNameElement.value = '';
                        if (autoCommandElement) autoCommandElement.value = '';
                        
                        const filterPatternElementReset = document.getElementById('filterPattern');
                        if (filterPatternElementReset) filterPatternElementReset.value = '';
                        
                        // Focus the name field
                        if (channelNameElement) channelNameElement.focus();
                    }
                } catch (error) {
                    console.error('Error saving tab configuration:', error);
                }
            }
            
            // Close tab configuration and return to chat
            closeTabConfig() {
                try {
                    console.log('Closing tab configuration');
                    
                    // Hide tab config
                    const tabConfigEl = document.getElementById('chatTabConfig');
                    if (tabConfigEl) {
                        tabConfigEl.style.display = 'none';
                    } else {
                        console.warn('Tab config element not found when trying to close');
                    }
                    
                    // Show the main chat interface again
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages) {
                        chatMessages.style.display = 'block';
                    }
                    
                    const chatInputContainer = document.getElementById('chatInputContainer');
                    if (chatInputContainer) {
                        chatInputContainer.style.display = 'flex';
                    }
                    
                    // Switch back to previous channel or 'all'
                    const lastChannel = this.currentChannel !== 'tab-config' ? 
                        this.currentChannel : (localStorage.getItem('sequoia2_lastActiveChannel') || 'all');
                    this.switchChannel(lastChannel);
                } catch (error) {
                    console.error('Error closing tab configuration:', error);
                    // Fallback - try to switch to 'all' channel
                    try {
                        this.switchChannel('all');
                    } catch (e) {
                        console.error('Failed to switch to fallback channel:', e);
                    }
                }
            }
            
            // Open edit tab configuration
            openEditTabModal(channelId) {
                try {
                    console.log(`Opening edit modal for channel ${channelId}`);
                    
                    // Simply use switchChannel to tab-config, which will handle all the visibility
                    this.switchChannel('tab-config');
                    
                    const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                    if (!tabElement) {
                        console.error(`Tab element not found for channel: ${channelId}`);
                        return;
                    }
                    
                    if (inputContainerElement) {
                        inputContainerElement.style.display = 'none';
                    } else {
                        console.warn('Chat input container element not found');
                    }
                    
                    // Show tab config
                    const tabConfigEl = document.getElementById('chatTabConfig');
                    if (tabConfigEl) {
                        tabConfigEl.style.display = 'flex';
                        
                        // Set up message type checkbox behavior
                        this.setupMessageTypeCheckboxes();
                    } else {
                        console.error('Tab config element not found');
                        return;
                    }
                    
                    // Set title for editing
                    const tabNameElement = tabElement.querySelector('.tab-name');
                    const tabName = tabNameElement ? tabNameElement.textContent : 'Unknown';
                    
                    const titleElement = document.getElementById('tabConfigTitle');
                    if (titleElement) {
                        titleElement.textContent = `Editing Tab '${tabName}'`;
                    }
                    
                    // Get tab data
                    const autoCommand = tabElement.getAttribute('data-auto-command') || '';
                    const consumeMessages = tabElement.getAttribute('data-consume') === 'true';
                    const filterPattern = tabElement.getAttribute('data-filter') || '';
                    const order = parseInt(tabElement.getAttribute('data-order')) || 1;
                    
                    // Set values in the form
                    const formElements = {
                        channelId: document.getElementById('channelId'),
                        channelName: document.getElementById('channelName'),
                        autoCommand: document.getElementById('autoCommand'),
                        channelOrder: document.getElementById('channelOrder'),
                        consumeMessages: document.getElementById('consumeMessages'),
                        filterPattern: document.getElementById('filterPattern')
                    };
                    
                    if (formElements.channelId) formElements.channelId.value = channelId;
                    if (formElements.channelName) formElements.channelName.value = tabName;
                    if (formElements.autoCommand) formElements.autoCommand.value = autoCommand;
                    if (formElements.channelOrder) formElements.channelOrder.value = order;
                    if (formElements.consumeMessages) formElements.consumeMessages.checked = consumeMessages;
                    if (formElements.filterPattern) formElements.filterPattern.value = filterPattern;
                
                    // Set message type checkboxes
                    const messageTypeCheckboxes = {
                        info: document.getElementById('msgTypeInfo'),
                        clientside: document.getElementById('msgTypeClientside'),
                        npc: document.getElementById('msgTypeNPC'),
                        global: document.getElementById('msgTypeGlobal'),
                        local: document.getElementById('msgTypeLocal'),
                        guild: document.getElementById('msgTypeGuild'),
                        party: document.getElementById('msgTypeParty'),
                        private: document.getElementById('msgTypePrivate'),
                        shout: document.getElementById('msgTypeShout'),
                        pets: document.getElementById('msgTypePets'),
                        gameMessage: document.getElementById('msgTypeGameMessage')
                    };
                    
                    // Safely set each checkbox
                    for (const [type, checkbox] of Object.entries(messageTypeCheckboxes)) {
                        if (checkbox) {
                            checkbox.checked = tabElement.getAttribute(`data-msg-${type}`) !== 'false';
                        }
                    }
                    
                    // Set up event listeners
                    this.setupTabConfigEventListeners();
                } catch (error) {
                    console.error('Error opening edit tab modal:', error);
                }
            }
            
            // Update the createNewTab and updateTab functions to handle the new message types
            // This is an updated version of the existing function with support for the new message types
            createNewTab(name, icon, autoCommand, messageTypes, consumeMessages, filterPattern, order) {
                try {
                    console.log(`Creating new tab: ${name}`);
                    
                    if (!name || name.trim() === '') {
                        console.error('Tab name cannot be empty');
                        return;
                    }
                    
                    // Generate a unique ID for the channel
                    const channelId = 'custom_' + Date.now();
                    
                    // Create the tab element
                    const tabElement = document.createElement('button');
                    tabElement.className = 'chat-tab';
                    tabElement.setAttribute('data-channel', channelId);
                    
                    // Set data attributes
                    if (autoCommand) {
                        tabElement.setAttribute('data-auto-command', autoCommand);
                    }
                    
                    // Set message type attributes
                    for (const [type, enabled] of Object.entries(messageTypes)) {
                        tabElement.setAttribute(`data-msg-${type}`, enabled);
                    }
                    
                    tabElement.setAttribute('data-consume', consumeMessages);
                    
                    if (filterPattern) {
                        tabElement.setAttribute('data-filter', filterPattern);
                    }
                    
                    if (order) {
                        tabElement.setAttribute('data-order', order);
                    }
                    
                    tabElement.innerHTML = `
                        <span class="material-icons">${icon}</span>
                        <span class="tab-name">${name}</span>
                    `;
                    
                    // Add it to the chat tabs
                    const chatTabs = document.querySelector('.chat-tabs');
                    if (chatTabs) {
                        chatTabs.appendChild(tabElement);
                        
                        // Add event listeners
                        tabElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.switchChannel(channelId);
                        });
                        
                        // Add context menu (right-click) event
                        tabElement.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.showTabContextMenu(e, channelId);
                        });
                        
                        // Switch to the new channel
                        this.switchChannel(channelId);
                        
                        // Store custom channels in localStorage for persistence
                        this.saveCustomChannels();
                    } else {
                        console.error('Chat tabs element not found');
                    }
                } catch (error) {
                    console.error('Error creating new tab:', error);
                }
            }
            
            // Update a tab with new settings - updated to handle new message types
            updateTab(channelId, name, icon, autoCommand, messageTypes, consumeMessages, filterPattern, order) {
                try {
                    console.log(`Updating tab: ${channelId}`);
                    
                    const tabElement = document.querySelector(`.chat-tab[data-channel="${channelId}"]`);
                    if (!tabElement) {
                        console.error(`Tab element not found for channel: ${channelId}`);
                        return;
                    }
                    
                    // Update visual elements
                    const tabNameElement = tabElement.querySelector('.tab-name');
                    if (tabNameElement) {
                        tabNameElement.textContent = name;
                    }
                    
                    // Update data attributes
                    if (autoCommand !== undefined) {
                        tabElement.setAttribute('data-auto-command', autoCommand);
                    }
                
                    // Update message type attributes
                    if (messageTypes) {
                        for (const [type, enabled] of Object.entries(messageTypes)) {
                            tabElement.setAttribute(`data-msg-${type}`, enabled);
                        }
                    }
                    
                    if (consumeMessages !== undefined) {
                        tabElement.setAttribute('data-consume', consumeMessages);
                    }
                    
                    if (filterPattern !== undefined) {
                        tabElement.setAttribute('data-filter', filterPattern);
                    }
                    
                    if (order) {
                        tabElement.setAttribute('data-order', order);
                    }
                    
                    // Save changes
                    this.saveCustomChannels();
                    
                    // If this is the active tab, refresh the display
                    if (tabElement.classList.contains('active')) {
                        this.switchChannel(channelId);
                    }
                } catch (error) {
                    console.error('Error updating tab:', error);
                }
            }
        }

        // Global instance
        let chat;
        
        // Initialize after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded, initializing chat');
            try {
                chat = new SequoiaChat();
                
                // Expose to window for Java integration
                window.sequoiaChat = chat;
                
                console.log('Chat initialized and exposed as window.sequoiaChat');
                
                // Send a test message for each channel to demonstrate functionality
                setTimeout(() => {
                    try {
                        console.log('Sending test messages to demonstrate channel functionality');
                        if (chat && typeof chat.receiveMessage === 'function') {
                            chat.receiveMessage('This is a test message in the global channel', Date.now(), 'global');
                            chat.receiveMessage('This is a test message in the guild channel', Date.now(), 'guild');
                            chat.receiveMessage('This is a test message in the party channel', Date.now(), 'party');
                            chat.receiveMessage('This is a private message', Date.now(), 'private');
                        } else {
                            console.warn('Chat not fully initialized yet, skipping test messages');
                        }
                    } catch (error) {
                        console.error('Error sending test messages:', error);
                    }
                }, 2000);
            } catch (error) {
                console.error('Error initializing chat:', error);
            }
        });

        // Java bridge
        window.javabridge = {
            receiveMessage: (content, timestamp, channel) => {
                try {
                    if (chat && typeof chat.receiveMessage === 'function') {
                        chat.receiveMessage(content, timestamp, channel);
                    } else {
                        console.error('Chat not initialized yet, cannot receive message');
                        // Queue messages to be processed when chat is ready
                        if (!window.messageQueue) {
                            window.messageQueue = [];
                        }
                        window.messageQueue.push({content, timestamp, channel});
                    }
                } catch (error) {
                    console.error('Error in receiveMessage bridge:', error);
                }
            },
            toggleChat: () => {
                try {
                    if (chat && typeof chat.toggleChat === 'function') {
                        chat.toggleChat();
                    } else {
                        console.error('Chat not initialized yet, cannot toggle');
                    }
                } catch (error) {
                    console.error('Error in toggleChat bridge:', error);
                }
            },
            openChat: () => {
                try {
                    if (chat && typeof chat.openChat === 'function') {
                        chat.openChat();
                    } else {
                        console.error('Chat not initialized yet, cannot open');
                    }
                } catch (error) {
                    console.error('Error in openChat bridge:', error);
                }
            },
            closeChat: () => {
                try {
                    if (chat && typeof chat.closeChat === 'function') {
                        chat.closeChat();
                    } else {
                        console.error('Chat not initialized yet, cannot close');
                    }
                } catch (error) {
                    console.error('Error in closeChat bridge:', error);
                }
            },
            handleKeyPress: (key) => {
                try {
                    if (chat && typeof chat.handleKeyPress === 'function') {
                        return chat.handleKeyPress(key);
                    } else {
                        console.error('Chat not initialized yet, cannot handle key press');
                    }
                } catch (error) {
                    console.error('Error in handleKeyPress bridge:', error);
                }
                return false;
            },
            switchChannel: (channel) => {
                try {
                    if (chat && typeof chat.switchChannel === 'function') {
                        chat.switchChannel(channel);
                    } else {
                        console.error('Chat not initialized yet, cannot switch channel');
                    }
                } catch (error) {
                    console.error('Error in switchChannel bridge:', error);
                }
            }
        };

        console.log('Sequoia2 Chat initialized');
    </script>
    
    <!-- Global Emoji Picker -->
    <div id="emoji-picker">
        <div class="emoji-picker-header">
            <div class="emoji-picker-tabs">
                <button class="emoji-picker-tab active" data-tab="emoji">Emoji</button>
                <button class="emoji-picker-tab" data-tab="stickers">Stickers</button>
                <button class="emoji-picker-tab" data-tab="gifs">GIFs</button>
            </div>
            <button id="emoji-picker-close" title="Close"></button>
        </div>
        <div class="emoji-picker-content">
            <div class="emoji-picker-search">
                <input type="text" id="emoji-search" placeholder="Search emojis...">
            </div>
            <div class="emoji-picker-body">
                <div id="emoji-category-nav" class="emoji-sidebar"></div>
                <div id="emoji-results" class="emoji-grid"></div>
            </div>
            <div id="emoji-preview">
                <div id="emoji-preview-emoji"></div>
                <div id="emoji-preview-name"></div>
            </div>
        </div>
        
        <!-- Stickers content (initially hidden) -->
        <div class="stickers-content" style="display:none;">
            <div class="emoji-picker-search">
                <input type="text" id="sticker-search" placeholder="Search stickers...">
            </div>
            <div class="stickers-grid"></div>
        </div>
        
        <!-- GIFs content (initially hidden) -->
        <div class="gifs-content" style="display:none;">
            <div class="emoji-picker-search">
                <input type="text" id="gif-search" placeholder="Search GIFs...">
            </div>
            <div class="gifs-grid"></div>
        </div>
    </div>
    
    <!-- Edit Channel Modal -->
    <div id="editChannelModal" class="chat-modal" style="display: none;">
        <div class="chat-modal-content">
            <div class="chat-modal-header">
                <h2>Edit Chat Tab</h2>
                <span class="chat-modal-close">&times;</span>
            </div>
            <div class="chat-modal-body">
                <input type="hidden" id="editChannelId">
                <div class="form-group">
                    <label for="editChannelName">Tab Name</label>
                    <input type="text" id="editChannelName" class="modal-input">
                </div>
                <div class="form-group">
                    <label for="editChannelIcon">Tab Icon</label>
                    <select id="editChannelIcon" class="modal-input">
                        <option value="tag">tag</option>
                        <option value="chat">chat</option>
                        <option value="forum">forum</option>
                        <option value="alternate_email">alternate_email</option>
                        <option value="mark_chat_unread">mark_chat_unread</option>
                        <option value="campaign">campaign</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="editAutoCommand">Auto Command</label>
                    <input type="text" id="editAutoCommand" class="modal-input" placeholder="e.g., /g">
                </div>
                <div class="form-group message-types-group">
                    <label>Message Types to Show</label>
                    <div class="checkbox-grid">
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypeGlobal" checked>
                            <label for="editMsgTypeGlobal">Global</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypeGuild" checked>
                            <label for="editMsgTypeGuild">Guild</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypeParty" checked>
                            <label for="editMsgTypeParty">Party</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypePrivate" checked>
                            <label for="editMsgTypePrivate">Private</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypeSystem" checked>
                            <label for="editMsgTypeSystem">System</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="editMsgTypeCombat" checked>
                            <label for="editMsgTypeCombat">Combat</label>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="editConsumeMessages">
                        <label for="editConsumeMessages">Consume Messages</label>
                    </div>
                </div>
                <div class="form-group">
                    <label for="editFilterPattern">Pattern Filter (RegEx)</label>
                    <input type="text" id="editFilterPattern" class="modal-input" placeholder="e.g., ^\\[!] .*">
                    <small class="help-text">Messages matching this pattern will be included in this tab</small>
                </div>
                <div class="button-row">
                    <button id="updateChannelBtn" class="modal-button">Update Tab</button>
                    <button id="deleteChannelBtn" class="modal-button delete-button">Delete Tab</button>
                </div>
            </div>
        </div>
    </div>
    
    <style>
        /* Styles for the tab editor */
        .modal-input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: #2f3136;
            border: 1px solid #202225;
            color: #dcddde;
            margin-top: 4px;
        }
        
        .modal-button {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: 500;
        }
        
        .modal-button:hover {
            background-color: #7761b7;
        }
        
        .delete-button {
            background-color: #d93c3c;
            margin-left: 8px;
        }
        
        .delete-button:hover {
            background-color: #e05e5e;
        }
        
        .button-row {
            display: flex;
            justify-content: space-between;
        }
        
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .checkbox-item label {
            cursor: pointer;
            font-size: 14px;
        }
        
        .help-text {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
        }
        
        .message-types-group {
            margin-bottom: 12px;
        }

        /* Context menu for tabs */
        .tab-context-menu {
            position: absolute;
            z-index: 1000;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 6px;
            box-shadow: 
                0 4px 16px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.08);
            padding: 6px 0;
            width: 180px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab-context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255, 255, 255, 0.9);
            transition: background-color 0.15s ease;
        }

        .tab-context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab-context-menu-item .material-icons {
            font-size: 18px;
            opacity: 0.9;
        }
    </style>
</body>
</html>
